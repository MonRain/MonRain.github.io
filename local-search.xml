<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java八股文</title>
    <link href="/2021/06/02/Java%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <url>/2021/06/02/Java%E5%85%AB%E8%82%A1%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li><input checked="" disabled="" type="checkbox"> [Java三大特性和详细聊聊多态](# 详细说一说Java的多态)</li><li><input checked="" disabled="" type="checkbox"> [static可以修饰什么？静态代码块什么时候执行？执行几次。](# static可以修饰什么？静态代码块什么时候执行？执行几次。)</li><li><input disabled="" type="checkbox"> [Java多态的底层原理](# 多态的底层实现（涉及到JVM方法调用）)</li><li><input disabled="" type="checkbox"> [你觉得Java有什么缺点？](# 你觉得Java有什么缺点？)</li><li><input checked="" disabled="" type="checkbox"> [线程与进程的区别](# 线程与进程的区别)</li><li><input checked="" disabled="" type="checkbox"> [原子性、可见性、有序性](# 原子性、可见性、有序性)</li><li><input checked="" disabled="" type="checkbox"> [wait()和block()区别](# wait()和block()区别)</li><li><input disabled="" type="checkbox"> [死锁成因及四个条件，怎样避免死锁](# 死锁成因及四个条件，怎样避免死锁)</li><li><input disabled="" type="checkbox"> [线程池原理和参数](# 线程池原理和参数)</li><li><input checked="" disabled="" type="checkbox"> [Synchronized和Volatile关键字](# Synchronized和Volatile关键字)</li><li><input disabled="" type="checkbox"> [乐观锁和悲观锁](# 乐观锁和悲观锁)</li></ul><h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h4 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h4><p>封装、继承、多态</p><h5 id="分别说说对三大特性的理解"><a href="#分别说说对三大特性的理解" class="headerlink" title="分别说说对三大特性的理解"></a>分别说说对三大特性的理解</h5><p>封装：封装就是指利用抽象数据类型将数据和基于数据的操作封装在一起，数据被保护在抽象类型的内部，系统的其他部分只有通过包裹在数据外面的被授权的操作，才能够与这个抽象数据类型交流与交互！</p><p>继承：继承实际上是存在于面向对象程序中的两个类之间的关系。当一个类拥有另一个类的所有数据和操作时，就称这两个类之间具有继承关系！</p><p>多态：多态是指一个程序中同名的不同方法共存的情况。面向对象的程序中多态的情况有多种，可以通过子类对父类方法的覆盖实现多态，也可以利用重载在同一个类中定义多个同名的不同方法！</p><h5 id="详细说一说Java的多态"><a href="#详细说一说Java的多态" class="headerlink" title="详细说一说Java的多态"></a>详细说一说Java的多态</h5><p>面向对象的三大特性是<u>封装、继承和多态</u>，从一定意义上讲，封装、继承都是为多态准备的。</p><blockquote><p>多态的定义：允许<strong>不同类</strong>的<strong>对象</strong>对同一操作做出不同的响应。</p><p>实现多态的技术：<strong>动态绑定</strong>（Dynamic Binding），指在<strong>运行期间</strong>判断<u>所引用对象</u>的<strong>实际类型</strong>，根据其实际的类型调用其<u>相应的方法</u>。</p><p>多态的作用：消除类型之间的<strong>耦合关系</strong>。</p><details><summary>多态的好处：<u>可替换性、可扩充性、接口性、灵活性、简化性</u></summary>1. 可替换性(substitutability)。多态对已存在代码具有可替换性。<br>   例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。<br>2. 可扩充性(extensibility)。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。<br>3. 接口性(interface-ability)。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。<br>4. 灵活性(flexibility)。它在应用中体现了灵活多样的操作，提高了使用效率。<br>5. 简化性(simplicity)。多态简化对应用软件的代码<u>编写和修改</u>过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</details></blockquote><h5 id="多态的底层实现（涉及到JVM方法调用）"><a href="#多态的底层实现（涉及到JVM方法调用）" class="headerlink" title="多态的底层实现（涉及到JVM方法调用）"></a>多态的底层实现（涉及到JVM方法调用）</h5><p>多态的底层实现是<strong>动态绑定</strong>，即在运行时才把<u>方法调用</u>与<u>方法实现</u>关联起来。</p><p>invokevirtual 和 invokeinterface 用于动态绑定。可以看出，动态绑定主要应用于<strong>虚方法</strong>和<strong>接口方法</strong>。</p><p><a href="https://blog.csdn.net/zmh458/article/details/101075633">从JVM的角度来看Java多态的底层原理</a></p><p><a href="https://juejin.cn/post/6844904005995364366">Java 多态的实现机制 - 掘金</a></p><blockquote><p>Tips：</p><p>JVM 的<strong>方法调用</strong>指令有五个：</p><ul><li><p>静态绑定</p><ul><li>invokestatic：调用<strong>静态方法</strong>；</li><li>invokespecial：调用<strong>实例构造器<init>方法</strong>、<strong>私有方法</strong>和<strong>父类方法</strong>；</li></ul></li><li><p>动态绑定</p><ul><li>invokevirtual：调用<strong>虚方法</strong>；</li><li>invokeinterface：调用<strong>接口方法</strong>，<u>运行时</u>确定具体实现；</li><li>invokedynamic：运行时<strong>动态解析所引用的方法</strong>，然后再执行，用于支持<u>动态类型语言</u>。</li></ul></li></ul><p><em>Java是用过方法表来实现的，C++是通过虚表来实现的。</em></p></blockquote><p><strong>核心思路</strong>：方法表中排列顺序为，Object类方法，父类方法，子类方法。无论子类有无重写父类方法，都视为父类方法，因此被重写和没有被重写的两种情况下，父类方法在方法表中的偏移量是固定的。当方法被重写时，方法表中记录的方法引用则只想子类方法区的重写代码，否则指向原父类方法区的代码。</p><h4 id="static可以修饰什么？静态代码块什么时候执行？执行几次。"><a href="#static可以修饰什么？静态代码块什么时候执行？执行几次。" class="headerlink" title="static可以修饰什么？静态代码块什么时候执行？执行几次。"></a>static可以修饰什么？静态代码块什么时候执行？执行几次。</h4><p>static可以修饰<strong>成员变量</strong>、<strong>方法</strong>、<strong>静待代码块</strong>和<strong>内部类</strong>。</p><p>静态代码块在类被<strong>加载</strong>的时候就运行，且只运行一次。</p><p>优先级：<strong>静态代码块&gt;构造代码块&gt;构造函数&gt;普通代码块</strong>　</p><h4 id="面向过程和面向对象的区别和性能对比"><a href="#面向过程和面向对象的区别和性能对比" class="headerlink" title="面向过程和面向对象的区别和性能对比"></a>面向过程和面向对象的区别和性能对比</h4><ul><li>面向过程 ：分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</li><li>面向对象 ：把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</li></ul><h5 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span> 面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。<br><span class="hljs-number">2.</span> 面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。<br></code></pre></td></tr></table></figure><h4 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h4><h5 id="ArrayQueue与LinkedListQueue的取舍"><a href="#ArrayQueue与LinkedListQueue的取舍" class="headerlink" title="ArrayQueue与LinkedListQueue的取舍"></a>ArrayQueue与LinkedListQueue的取舍</h5><p>ArrayQueue由循环数组实现，容量有限，但实现效率高。</p><p>LinkedListQueue由链表实现，理论上容量无限，但实现效率较低。</p><h5 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h5><p><a href="https://segmentfault.com/a/1190000021433933">Java集合系列之四：HashMap底层原理- SegmentFault 思否</a></p><h5 id="ArrayList底层实现"><a href="#ArrayList底层实现" class="headerlink" title="ArrayList底层实现"></a>ArrayList底层实现</h5><h4 id="你觉得Java有什么缺点？"><a href="#你觉得Java有什么缺点？" class="headerlink" title="你觉得Java有什么缺点？"></a>你觉得Java有什么缺点？</h4><ul><li>使用大量的内存。 靠虚拟机运行，运行速度相对较慢。</li><li>不能和底层打交道，不支持底层操作。</li><li>启动时间慢。</li><li>因为<strong>Java</strong>删除了指针，所以不如C/C++等语言灵活。</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="线程、进程、协程"><a href="#线程、进程、协程" class="headerlink" title="线程、进程、协程"></a>线程、进程、协程</h4><blockquote><p>进程是相对于操作系统而言，每个运行一个应用程序就是运行一个进程。</p><p>线程是相对于进程而言，一个进程可以有多个线程，至少有一个线程。</p></blockquote><blockquote><p>进程依托于操作系统，可以理解为操作系统的子项目，多个进程可以在一个操作系统下运行。</p><p>线程依托于进程，可以理解为一个进程的子项目，一个进程可以同时运行多个线程完成特定任务。</p></blockquote><blockquote><p>协程是更加轻量级的实现，在线程内部，可以实现不同代码的交替执行（函数间的并发）。</p><ul><li>解释：一般的函数执行都是通过函数调用栈顺序执行。协程间可以交替运行。也拥有自己的寄存器和栈，被切换时，将寄存器和栈保存起来，恢复时继续运行。</li></ul><p>与线程与进程的对比：</p><ul><li>协程既可以由线程拥有，也可以由进程独立拥有</li><li>协程是非抢占性的</li></ul></blockquote><h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><p>并发：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。</p><p>并行：当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。</p><h4 id="实现线程安全的几种基本方法"><a href="#实现线程安全的几种基本方法" class="headerlink" title="实现线程安全的几种基本方法"></a>实现线程安全的几种基本方法</h4><ul><li>synchronized</li><li>volatile</li><li>无状态设计</li><li>ThreadLocal</li></ul><h4 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h4><p>原子性：<strong>一个操作是不可中断的，要么全部执行成功要么全部执行失败</strong>。</p><p>有序性：对应<strong>指令重排</strong>，一串代码由于某种需求只能顺序执行，要禁止指令重排。</p><p>可见性：对应JVM内存模型中线程的局部内存，当一个线程对共享变量作出修改时，其它线程能立即获取到修改。</p><blockquote><p>Java内存模型中定义了8中操作都是<strong>原子</strong>的，不可再分的。</p><p>lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；</p><p>unlock(解锁):作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</p><p>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用；</p><p>load（载入）：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本</p><p>use（使用）：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；</p><p>assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；</p><p>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用；</p><p>write（操作）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</p></blockquote><h4 id="waiting和blocked区别"><a href="#waiting和blocked区别" class="headerlink" title="waiting和blocked区别"></a>waiting和blocked区别</h4><p>java线程中含有waiting与blocked两种状态</p><ul><li>WAITING: 当线程调用调用<code>Object.wait()</code>时，线程，进入<code>waiting</code>状态进入<font color='red'><strong>等待队列</strong></font> 。等待其它线程<strong>同一对象</strong>调用<code>notify()</code>或<code>notifyAll()</code>。</li><li>BLOCKED: 出现到<code>notify()</code>或<code>notifyAll()</code>的调用时，线程解除<code>waiting</code>状态。<u>但同一时间可能有其他线程竞争<strong>对象监视器</strong></u>，因此可能无法立即运行，因此会进入<font color='red'><strong>同步队列</strong></font>，准备竞争<strong>对象监视器</strong>，此时线程处于<code>blocked</code>状态。</li></ul><blockquote><p>Tips: 什么是对象监视器？</p><p><a href="https://www.cnblogs.com/keeplearnning/p/7020287.html">锁和监视器之间的区别 – Java并发</a></p></blockquote><h4 id="死锁成因及四个条件，怎样避免死锁"><a href="#死锁成因及四个条件，怎样避免死锁" class="headerlink" title="死锁成因及四个条件，怎样避免死锁"></a>死锁成因及四个条件，怎样避免死锁</h4><p><a href="https://www.jianshu.com/p/44125bb12ebf">死锁是什么？如何避免死锁？</a></p><h5 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h5><p><em>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</em></p><p>当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生<strong>AB两个线程由于互相持有对方需要的锁</strong>，而发生的阻塞现象，我们称为死锁。</p><h5 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h5><ol><li>因为系统资源不足。</li><li>进程运行推进的顺序不合适。</li><li>资源分配不当等。</li></ol><p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。</p><h5 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h5><ul><li>互斥<strong>条件</strong>：一个资源每次只能被一个进程使用。</li><li>请求与保持<strong>条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺<strong>条件</strong>:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待<strong>条件</strong>:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><h5 id="怎么避免死锁"><a href="#怎么避免死锁" class="headerlink" title="怎么避免死锁"></a>怎么避免死锁</h5><p>教科书回答：<a href="https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">哲学家就餐问题</a>解法：服务生解法、资源分级解法、Chandy/Misra解法。</p><p>避免死锁就是破坏<strong>造成死锁的若干条件中的任意一个</strong></p><h4 id="线程池原理和参数"><a href="#线程池原理和参数" class="headerlink" title="线程池原理和参数"></a>线程池原理和参数</h4><h4 id="Synchronized和Volatile关键字"><a href="#Synchronized和Volatile关键字" class="headerlink" title="Synchronized和Volatile关键字"></a>Synchronized和Volatile关键字</h4><h5 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h5><p>通过指定关联一个对象（<em>关联的对象具体分类</em>），利用monitor机制（<strong>说说monitor机制</strong>），实现同一时刻只有一个线程对所辖区域（临界区）的对象、方法、代码块等的访问和执行。</p><p>底层实现原理是在相关字节码两端添加monitorenter和monitorexit。</p><blockquote><p>每个线程执行到monitorenter时，会检查相关monitor对象的计数器是否为0，</p><ul><li>不为0等待，转换为阻塞状态。</li><li>为0，当前线程成为monitor的拥有者，所著该监视器对象并计数器加1。</li></ul><p>每个线程执行到monitorexit时，monitor计数器减1。其它线程竞争monitor。</p></blockquote><h5 id="volatile关键字的作用"><a href="#volatile关键字的作用" class="headerlink" title="volatile关键字的作用"></a><strong>volatile关键字的作用</strong></h5><p><a href="https://www.huaweicloud.com/articles/35441765987af15d9806b88fe8cf6045.html">40个Java多线程问题总结</a></p><h6 id="两个作用"><a href="#两个作用" class="headerlink" title="两个作用"></a>两个作用</h6><blockquote><ul><li>维护线程可见性：使用volatile关键字修饰的对象在某一线程内部内存中被修改后会被<strong>立即同步</strong>到主内存。避免线程内部更新之后，其它线程对被更新对象不可见。</li><li>禁止指令重排：禁止由于指令重排造成多线程操作同一对象引起的线程不安全。</li></ul></blockquote><h6 id="不具有原子性"><a href="#不具有原子性" class="headerlink" title="不具有原子性"></a>不具有原子性</h6><p>由于它只是及时将修改更新到主内存，但不能保证同一时刻只有一个线程对对象进行操作。</p><p>一个线程在操作局部内存的变量时，另一个线程也可能同时在操作对应局部内存的相同变量。因此在进行复杂操作时，不能保证原子性。</p><p>举例：</p><p><code>i=1</code>操作为，赋值。是原子操作。</p><p><code>i++</code>操作为，取i的值，自增，赋值三个操作。不是原子操作。</p><p>可以使用Java多线程的封装包自带的线程安全包实现原子性，如Integer对应的AtomInteger。</p><h5 id="说一说Synchronized和Volatile以及区别"><a href="#说一说Synchronized和Volatile以及区别" class="headerlink" title="说一说Synchronized和Volatile以及区别"></a>说一说Synchronized和Volatile以及区别</h5><h6 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h6><p>都可以在功能上实现可见性、有序性。</p><h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><p>实现方式不同，只是都能实现功能。</p><ul><li><p>Synchronized通过锁住整个代码块，其它相关进程阻塞，执行完成之后将所有修改同步到主内存，实现<strong>可见性</strong>，其他进程继续竞争监视器，继续执行，实现<strong>有序性</strong>。</p></li><li><p>volatile：一个线程对共享变量发生修改之后立即同步到主内存，并使其它局部内存相关共享变量副本失效，下次别的线程使用改变量时，从主内存同步，实现<strong>可见性</strong>。禁止指令重排实现<strong>有序性</strong>。</p></li></ul><p>volatile更轻量级，但无法实现原子性。</p><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><p><a href="https://www.cnblogs.com/kismetv/p/10787228.html">参考</a></p><p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p><ul><li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li><li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li></ul><h4 id="解决线程安的四种方案"><a href="#解决线程安的四种方案" class="headerlink" title="解决线程安的四种方案"></a>解决线程安的四种方案</h4><h5 id="synchronize"><a href="#synchronize" class="headerlink" title="synchronize"></a>synchronize</h5><h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><h5 id="无状态编程"><a href="#无状态编程" class="headerlink" title="无状态编程"></a>无状态编程</h5><p>无状态的方法：方法只包含使用</p><ul><li>方法调用传递进来的参数数据</li><li>方法内部定义的局部变量</li></ul><h5 id="threadlocal"><a href="#threadlocal" class="headerlink" title="threadlocal"></a>threadlocal</h5><p>每个线程使用ThreadLocal类包装一个对于共享变量的独立副本，操作只对副本操作。空间换时间。</p><h4 id="线程池常用参数"><a href="#线程池常用参数" class="headerlink" title="线程池常用参数"></a>线程池常用参数</h4><p><strong>线程池</strong>(<strong>ThreadPoolExecutor</strong>)存储线程的一个”容器”，方便我们从中取线程用，负责托管线程操作。</p><p>corePoolSize(核心线程数量)（最小线程数）</p><p>workQueue(任务队列)</p><p>maximumPoolSize(最大线程数)</p><p>RejectedExecutionHandler</p><p>keepAliveTime</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p><a href="https://doocs.github.io/jvm">JVM 底层原理最全知识总结</a></p><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p><img src="https://pic4.zhimg.com/80/v2-ecf6c3d0f5146029e9693d6223d23afb_720w.jpg" alt="img"></p><h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>类加载过程是指从<strong>字节码文件</strong>中读取二进制数据到内存中准备运行。</p><p>字节码文件：一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译</p><p>从开发者的角度而言，类的加载器有四种</p><ul><li><p>启动（Bootstrap）类加载器：由C++编写。负责将 Java_Home/lib下面的java核心类库加载到内存中。无法直接调用。</p><p>并不是继承自java.lang.ClassLoader，它没有父类加载器</p><p>它加载<code>扩展类加载器</code>和<code>应用程序类加载器</code>，并成为他们的父类加载器</p></li><li><p>标准扩展（Extension）类加载器：由java编写。它负责将Java_Home /lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</p><p>派生继承自java.lang.ClassLoader，父类加载器为<code>启动类加载器</code></p></li><li><p>应用程序（Application）类加载器：由java编写。它负责加载<code>环境变量classpath</code>或者<code>系统属性java.class.path</code>指定路径下的类库。</p><p>程序默认类加载器。</p></li><li><p>自定义类加载器。</p></li></ul><h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><h6 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h6><p><u>主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。</u></p><p>对于<strong>文件格式的验证</strong>，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p><p>对于<strong>元数据的验证</strong>，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p><p>对于<strong>字节码的验证</strong>，保证程序语义的合理性，比如要保证类型转换的合理性。</p><p>对于<strong>符号引用的验证</strong>，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p><h6 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h6><p><u>主要是为<strong>类变量</strong>（注意，不是实例变量）分配内存，并且赋予<strong>初值</strong>。</u></p><blockquote><p>特别需要注意，<strong>初值，不是代码中具体写的初始化的值</strong>，而是Java虚拟机根据不同变量类型的默认初始值。</p><ul><li>8种<strong>基本类型</strong>的初值，默认为0；</li><li><strong>引用类型</strong>的初值则为null；</li><li><strong>常量</strong>的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456</li></ul></blockquote><h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><p><u>将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程。</u></p><p>两个重点：</p><ul><li><strong>符号引用</strong>。即一个字符串，这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。</li><li><strong>直接引用</strong>。可以理解为一个内存地址，或者一个偏移量。比如<strong>类方法，类变量</strong>的直接引用是指向方法区的<strong>指针</strong>；而<strong>实例方法，实例变量</strong>的直接引用则是从实例的头指针开始算起到这个实例变量位置的<strong>偏移量</strong></li></ul><blockquote><p>如调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p><p>在解析阶段，虚拟机会把所有的<u>类名，方法名，字段名</u>（<strong>符号引用</strong>）这些符号引用替换<strong>直接引用</strong>。</p></blockquote><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>这个阶段主要是对<strong>类变量</strong>初始化，是执行类构造器的过程。</p><blockquote><p><u>只对static修饰的变量或语句进行初始化。</u></p><p>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</p><p>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p></blockquote><h4 id="GC算法：GarbageCollection垃圾收集"><a href="#GC算法：GarbageCollection垃圾收集" class="headerlink" title="GC算法：GarbageCollection垃圾收集"></a>GC算法：GarbageCollection垃圾收集</h4><blockquote><ul><li>Java中，<strong>GC的对象是Java堆和方法区</strong>（即永久区）</li><li>标记-清除算法：最经典的GC算法</li><li>标记-整理算法：老年代GC</li><li>复制收集算法：新生代GC</li><li>分代收集算法：新生代+老年代GC</li><li>引用计数算法：没有被Java采纳</li><li>问题提炼：<ul><li>GC算法说明</li><li>解释可触及性</li><li>Stop-the-world的原因和危害</li></ul></li></ul></blockquote><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p><strong>从根开始</strong>将可能被引用的对象用<strong>递归</strong>的方式进行<strong>标记</strong>（标记称为可达标识），然后将<strong>没有标记</strong>到的对象作为垃圾进行<strong>回收</strong>。<br><img src="https://images0.cnblogs.com/blog/641601/201508/201002497066258.png" alt="7de44970-2e02-46a1-a5d0-0663b21906c6"></p><blockquote><p>问题：</p><ul><li>效率问题：首先，<strong>它的缺点就是效率比较低（递归与全堆对象遍历）</strong>；</li><li>空间问题：主要的缺点，则是<strong>这种方式清理出来的空闲内存是不连续的</strong><ul><li>空间碎片太多会导致大内存对象无法生成而频繁进行GC。</li><li>JVM就不得不维持一个内存的空闲列表，这又是一种开销。</li><li>而且在分配数组对象的时候，寻找连续的内存空间会不太好找。</li></ul></li></ul></blockquote><h5 id="标记-整理算法：（老年代的GC）"><a href="#标记-整理算法：（老年代的GC）" class="headerlink" title="标记-整理算法：（老年代的GC）"></a>标记-整理算法：（老年代的GC）</h5><p>和<u>标记-清除算法</u>一样，从根节点开始，标记所有可达对象；</p><p>之后，它并不简单的清理未标记的对象，而是<strong>将所有的存活对象压缩到内存的一端；</strong></p><p>之后，清理边界外所有的空间。</p><p><img src="https://images0.cnblogs.com/blog/641601/201508/201003005357866.png" alt="cc79889a-0856-4018-92c3-c51108c9caea"></p><blockquote><ul><li><p>标记-压缩算法适合用于存活对象较多的场合，如老年代。</p></li><li><p>内存空间整齐</p></li></ul></blockquote><h5 id="复制收集算法：（新生代的GC）"><a href="#复制收集算法：（新生代的GC）" class="headerlink" title="复制收集算法：（新生代的GC）"></a>复制收集算法：（新生代的GC）</h5><p>将原有的内存空间<strong>分为两块</strong>，每次只使用其中一块，使用块称为<u>内存1</u>，未使用称为<u>内存2</u>。</p><p>在垃圾回收时，将<u>内存1</u>的<strong>存活对象</strong>复制到<u>内存2</u>中</p><p>之后，清除<u>内存1</u>所有对象，交换两个内存的角色，完成垃圾回收。</p><p><img src="https://images0.cnblogs.com/blog/641601/201508/201002560357091.png" alt="ff1e1846-e49c-4663-aee1-7c63628f567c"></p><blockquote><p>问题</p><ul><li><p><strong>最大问题：空间浪费</strong>：实际可用内存缩小为原来的一半。</p></li><li><p><strong>对象存活率较高</strong>时就要进行较多的复制操作，效率变低</p><ul><li>不适用于<strong>存活对象较多</strong>的场合，如老年代（复制算法<strong>适合做新生代的GC</strong>）</li></ul></li></ul><p>现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“<em>朝生夕死</em>”的，所以<u>并不需要按照1:1的比例来划分内存空间</u>。</p></blockquote><h5 id="分代收集算法：（新生代的GC-老年代的GC）"><a href="#分代收集算法：（新生代的GC-老年代的GC）" class="headerlink" title="分代收集算法：（新生代的GC+老年代的GC）"></a>分代收集算法：（新生代的GC+老年代的GC）</h5><p>把Java堆分为新生代和老年代：<strong>短命对象归为新生代，长命对象归为老年代</strong></p><ul><li><p><strong>少量对象存活，适合复制算法</strong>：</p><p>在<strong>新生代</strong>中，每次GC时都发现有大批对象死去，只有少量存活。</p><p>选用<strong>复制算法</strong>，只需要付出<strong>少量存活对象的复制成本</strong>就可以完成GC。</p></li><li><p><strong>大量对象存活，适合用标记-清理/标记-整理</strong>：</p><p>在<strong>老年代</strong>中，对象<strong>存活率高</strong>、没有额外空间对他进行分配担保，必须使用“<strong>标记-清理</strong>”/“<strong>标记-整理</strong>”算法进行GC。</p></li></ul><h5 id="引用计数算法：（没有被Java采纳）"><a href="#引用计数算法：（没有被Java采纳）" class="headerlink" title="引用计数算法：（没有被Java采纳）"></a>引用计数算法：（没有被Java采纳）</h5><p>给对象中添加一个<strong>引用计数器</strong>；</p><p>每有一个地方<strong>引用</strong>它，计数器值<strong>加1</strong>；</p><p>当<strong>引用失效</strong>时，计数器值就<strong>减1</strong>；</p><p>任何时刻<strong>计数器为0</strong>的对象就是不可能再被使用的。</p><blockquote><p>应用举例</p><ul><li>微软COM技术ComputerObjectModel</li><li>Python</li></ul><p>问题</p><ul><li><p>引用和去引用伴随加法和减法，影响性能</p></li><li><p>无法处理循环引用（致命）</p><p><img src="https://images0.cnblogs.com/blog/641601/201508/201002460667613.png" alt="1a489e67-e047-408f-a97e-4a141e6ab3b0"></p></li></ul></blockquote><h5 id="其它术语"><a href="#其它术语" class="headerlink" title="其它术语"></a>其它术语</h5><p><strong>可触及性：</strong></p><blockquote><p>所有的算法，需要能够识别一个垃圾对象，因此需要给出一个可触及性的定义。</p><p><strong>可触及的：</strong></p><p>　　从根节点可以触及到这个对象。</p><p>　　其实就是从根节点扫描，只要这个对象在引用链中，那就是可触及的。</p><p><strong>可复活的：</strong></p><p>　　一旦所有引用被释放，就是可复活状态</p><p>　　因为在finalize()中可能复活该对象</p><p><strong>不可触及的：</strong></p><p>　　在finalize()后，可能会进入不可触及状态</p><p>　　不可触及的对象不可能复活</p><p>　　要被回收。</p></blockquote><p><strong>Stop-The-World：</strong></p><blockquote><p><strong>1、Stop-The-World概念：</strong></p><p>　　Java中一种全局暂停的现象。</p><p><strong>全局停顿，所有Java代码停止</strong>，native代码可以执行，但不能和JVM交互</p><blockquote><p><strong>多半情况下是由于GC引起</strong>。<br> 少数情况下由其他情况下引起，如：Dump线程、死锁检查、堆Dump。</p></blockquote><p><strong>2、GC时为什么会有全局停顿？</strong></p><p>（1）避免无法彻底清理干净</p><ul><li>防止<strong>新的垃圾同时产生</strong>，永远无法彻底清理干净</li></ul><p>（2）GC的工作必须在一个能确保<strong>一致性</strong>的快照中进行。</p><ul><li><p>这里的一致性的意思是：在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现<strong>分析过程中对象引用关系还在不断变化</strong>的情况，该点不满足的话分析结果的准确性无法得到保证。</p></li><li><p>简而言之：减轻GC算法难度，动态运行容易使GC难以<strong>判断哪些是垃圾</strong>。</p></li><li><p>这点是导致GC进行时<strong>必须停顿所有Java执行线程</strong>的其中一个<strong>重要原因</strong>。</p></li></ul><p><strong>3、Stop-The-World的危害：</strong></p><blockquote><p><strong>长时间服务停止，没有响应（将用户正常工作的线程全部暂停掉）</strong></p><p>遇到HA系统，可能引起<u>主备切换</u>，严重危害生产环境。</p><p>　　备注：HA：HighAvailable,高可用性集群。</p></blockquote></blockquote><p><a href="https://www.cnblogs.com/qianguyihao/p/4744233.html">https://www.cnblogs.com/qianguyihao/p/4744233.html</a></p><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p><a href="https://segmentfault.com/a/1190000037547621">7种垃圾回收器</a></p><h5 id="JVM堆内存结构"><a href="#JVM堆内存结构" class="headerlink" title="JVM堆内存结构"></a>JVM堆内存结构</h5><p><img src="https://segmentfault.com/img/bVcHwwL" alt="image.png"></p><p>堆内存被划分为<strong>新生代</strong>和<strong>老年代</strong>，默认情况下配比为1：2（<a href="https://www.huaweicloud.com/articles/88f02bed9758df13a11f241044f88226.html">可以通过参数–XX:NewRatio 来指定</a>）。</p><p>新生代中，划分为Eden取和两个Survivor区（s0,s1）默认比例为8：1：1。</p><h5 id="JVM内存回收流程"><a href="#JVM内存回收流程" class="headerlink" title="JVM内存回收流程"></a>JVM内存回收流程</h5><ul><li>新生代区域<ul><li>新生成的对象进入Eden区。Eden满了触发Minor GC。存活的对象进入s0。</li><li>s0满了触发Minor GC。存活的对象进入s1。</li><li>s1满了触发Minor GC。存活的对象进入s0。</li><li>… 重复2，3操作，被转移对象每一次转移空间就长一岁，当到达某个值（15）时，进入老年代空间 … </li></ul></li><li>老年代区域<ul><li>每发生一次Minor GC，老年代都可能出现Major GC，视垃圾回收器而定。</li></ul></li></ul><p><strong>Stop the World问题</strong>：任何一种GC算法发生，都会导致Stop the World。</p><h5 id="垃圾回收器-1"><a href="#垃圾回收器-1" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h5><p><img src="https://segmentfault.com/img/bVcHHZL" alt="image.png"></p><p>新生代可配置的回收器：Serial、ParNew、Parallel Scavenge</p><p>老年代配置的回收器：CMS、Serial Old、Parallel Old</p><p>纵向概括：</p><ul><li>第一代：串行（Serial，Serial Old）</li><li>第二代：并行（ParNew，Parallel Old）</li><li>第三代：CMS，Parallel Scavenge</li><li>第四代：G1（Garbage First）</li></ul><p>新生代和老年代区域的回收器之间进行连线，说明他们之间可以搭配使用。</p><h6 id="新生代垃圾回收器"><a href="#新生代垃圾回收器" class="headerlink" title="新生代垃圾回收器"></a>新生代垃圾回收器</h6><ul><li><p>Serial回收器</p><p>最基本的、历史最悠久的回收器，俗称”串行回收器“，使用<strong>复制算法</strong>。</p><ul><li>优势：单线程，减少上下文切换的系统开销。</li><li>劣势：会STW（Stop The World），但对于新生代，存活对象少，停留时间短。</li></ul></li><li><p>ParNew（Parallel New）</p><p>就是Serial的并行版本，同样使用<strong>复制算法</strong>，其它参数也和Serial一样。</p><p>这里的并行指的是<strong>垃圾收集</strong>是并行的，并非<del>垃圾收集和程序运行并行</del>。</p><ul><li>优势：多线程执行，效果会比Serial好。</li><li>劣势：在单核CPU上，涉及到线程切换，反而会比Serial差。</li></ul></li><li><p>Parallel Scavenge</p><p>与ParNew相似，都是使用<strong>并行</strong>收集和<strong>复制算法</strong>。</p><p>特点是更关注<strong>吞吐量</strong>：<br>$$<br>吞吐量=\frac{代码运行时间}{代码运行时间+垃圾收集时间}<br>$$<br>这个结果越高，说明垃圾收集时间越短。</p><p>可以使用两个参数来控制：</p><ol><li><p><strong>-XX:MaxGCPauseMillis</strong>，<u>最大垃圾回收停顿时间。</u>这个参数的原理是空间换时间，收集器会<strong>控制新生代的区域大小，从而尽可能保证回收少于这个最大停顿时间</strong>。简单的说就是回收的区域越小，那么耗费的时间也越小。 所以这个参数并不是设置得越小越好。设太小的话，新生代空间会太小，从而更频繁的触发GC。</p></li><li><p><strong>-XX:GCTimeRatio</strong>，<u>垃圾回收时间与总时间占比。</u>这个是<strong>吞吐量的倒数</strong>，原理和MaxGCPauseMillis相同。</p></li></ol></li></ul><h6 id="老年代垃圾回收器"><a href="#老年代垃圾回收器" class="headerlink" title="老年代垃圾回收器"></a>老年代垃圾回收器</h6><ul><li><p>Serial Old</p><p>Serial的老年代版本，区别在于使用<strong>标记-整理算法</strong>。</p></li><li><p>Parallel Old</p><p>Parallel Scavenge的老年代版本，区别在于使用<strong>标记-整理算法</strong>。</p></li><li><p>CMS（Concurrent Mark Sweep）</p><p>更加关注<strong>最短回收停顿时间</strong>。使用<strong>标记-清除算法</strong></p><p>亮点在于<strong>Concurrent</strong>，意为和在<strong>程序代码执行的同时</strong>进行<strong>并发垃圾收集</strong>。</p><p>整个过程分为4个步骤：</p><p>（1）初始标记；</p><p>（2）并发标记；</p><p>（3）重新标记；</p><p>（4）并发清除。</p><p>其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”</p><ul><li>优势<ul><li>并发收集</li><li>低停顿</li></ul></li><li>劣势<ul><li>并发收集决定了它需要一定内存，如果内存增长很快，它自己的内存不够了，就会失败。此时JVM就会启动Serial Old来擦屁股。</li><li>标记-清除算法导致内存不连续，出现内存碎片可以通过参数设置来决定回收之后或多少次回收之后进行一次内存整理。</li></ul></li></ul></li></ul><h6 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h6><p>JDK1.7后的新收集器，用于取代CMS。（独立于新生代和老年代垃圾回收器）</p><p><a href="https://zhuanlan.zhihu.com/p/59861022">深入剖析JVM：G1收集器+回收流程+推荐用例</a></p><ul><li>特点<ul><li>引入分区概念，弱化分代概念。</li><li>合理利用垃圾收集各个周期的资源，解决其它收集器的缺陷。</li></ul></li><li>G1把堆平均分为几个区域Region，每个区域中虽然还存在新生代和老年代（逻辑上），但GC针对整个区域。</li><li>G1在回收内存后会马上同时做合并空闲内存的工作、而CMS默认是在STW（stop the world）的时候做。</li><li>G1会在Young GC中使用、而CMS只能在O区使用。</li></ul><h6 id="JDK-11：ZGC"><a href="#JDK-11：ZGC" class="headerlink" title="JDK 11：ZGC"></a>JDK 11：ZGC</h6><p>同时保证吞吐量、低延迟。</p><h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><h5 id="自定义的类和Java库里的类名字一样，JVM如何区分它们？"><a href="#自定义的类和Java库里的类名字一样，JVM如何区分它们？" class="headerlink" title="自定义的类和Java库里的类名字一样，JVM如何区分它们？"></a>自定义的类和Java库里的类名字一样，JVM如何区分它们？</h5><blockquote><p>在Java语言中，任何一个类，都要由加载它的类加载器和这个类自己共同确定它在JVM中的唯一性。<br>也就是说两个类相等必须满足两个条件：</p><ol><li>这两个类是被<strong>同一个类加载器</strong>加载的</li><li>这两个类的**.class路径和名字**是相同的。<br>另外，双亲委派：如果你自己定义了一个与jdk自带类名包名一致的类，那么java也不会去加载该类。</li></ol></blockquote><h5 id="双亲委派-1"><a href="#双亲委派-1" class="headerlink" title="双亲委派"></a>双亲委派</h5><p>（1）如果一个<code>类加载器</code>接收到了<code>类加载</code>的请求，它自己不会先去加载，会把这个请求委托给<code>父类加载器</code>去执行。</p><p>（2）如果父类还存在父类加载器，则继续向上委托，一直委托到<code>启动类加载器：Bootstrap ClassLoader</code></p><p>（3）如果父类加载器可以完成加载任务，就返回成功结果，如果父类加载失败，就由子类自己去尝试加载，如果子类加载失败就会抛出<code>ClassNotFoundException</code>异常，这就是<code>双亲委派模式</code></p><img src="https://img-blog.csdn.net/20170625231013755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom: 67%;" /><h3 id="Java框架"><a href="#Java框架" class="headerlink" title="Java框架"></a>Java框架</h3><p><a href="https://segmentfault.com/a/1190000016917114">Java 程序员必备的15 个框架，前3 个地位无可动摇 …</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的基本操作</title>
    <link href="/2021/04/22/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/04/22/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h1><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><h3 id="基本的创建线程操作"><a href="#基本的创建线程操作" class="headerlink" title="基本的创建线程操作"></a>基本的创建线程操作</h3><p>在Java中，线程操作被包装成了<code>Thread</code>类，因此使用</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-keyword">Thread</span> myThread = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Thread</span>()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>即可创建一个线程。</p><p>在此线程一般使用<code>myThread.start()</code>方法来启动，表现为新的线程执行一次内置的<code>run()</code>方法。但默认状态下，<code>run()</code>方法并不执行任何操作，是一个空方法。</p><p>对于一个自定义线程来说，可以继承<code>Thread</code>类之后重写<code>run()</code>方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><span class="hljs-meta">@Override</span><br>public void run()&#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;This is a new tread!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多继承问题"><a href="#多继承问题" class="headerlink" title="多继承问题"></a>多继承问题</h3><p>Java并不支持多继承，这导致我们新建自定义线程之后无法集成其它类。<code>Runnable</code>接口解决了这个问题。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OtherClass</span> <span class="hljs-title">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;This thread is got by implementing the Runnable interface!&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> MainClass&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span>&#123;<br>Thread myThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread())<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此之中，我们向<code>Thread</code>的构造函数中传递了一个继承<code>Runnable</code>接口的类。</p><p>实际上，<code>Thread</code>本身就是基于一个空的<code>Runnable</code>新建的，我们只不过是替换了它而已：</p><h2 id="线程之间的简单交互"><a href="#线程之间的简单交互" class="headerlink" title="线程之间的简单交互"></a>线程之间的简单交互</h2><p>基本的线程间交互可以解释为：</p><blockquote><p>子线程.join(): 主线程阻塞，等待子线程完成<br>线程.sleep(n): 当前线程等待n时间，让出CPU给其它线程，需要抓取中断异常。（当前线程绝对需要等待）<br>线程.yeild(): 当前线程让出CPU，与同优先级的其他线程一起竞争。（当前线程有竞争机会）<br>线程协作：O.wait()和O.notify()通过传递Object实现线程协作，如生产者消费者模式</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java高并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>高并发</tag>
      
      <tag>Thread对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>厘清Keras中的shape,unit,input_shape</title>
    <link href="/2021/03/05/%E5%8E%98%E6%B8%85Keras%E4%B8%AD%E7%9A%84shape-unit-input-shape-input-dim/"/>
    <url>/2021/03/05/%E5%8E%98%E6%B8%85Keras%E4%B8%AD%E7%9A%84shape-unit-input-shape-input-dim/</url>
    
    <content type="html"><![CDATA[<h1 id="厘清Keras中的shape-unit-input-shape"><a href="#厘清Keras中的shape-unit-input-shape" class="headerlink" title="厘清Keras中的shape,unit,input_shape"></a>厘清Keras中的shape,unit,input_shape</h1><p>新人（没错正是在下）在个性化Github上的Keras代码时，常常会遇到各种输入输出维度的报错，因此打算仔细梳理一下关于里面的shape, unit(Dense等Layer层的必需参数), input_shape, input_dim等参数。</p><h2 id="顾名思义TensorFlow"><a href="#顾名思义TensorFlow" class="headerlink" title="顾名思义TensorFlow"></a>顾名思义TensorFlow</h2><p>由于TensorFLow以及将Keras封为御用前端，因此笔者的所有Keras代码都是基于<code>tensorflow.keras</code>包实现的。但这里要说的不是二者的关系，而是借助这个<code>tensorflow</code>这个名称了解Keras的各层之间的运行关系。</p><p>Tensor本意为“张量”，可以理解为高维度的向量，也可姑且理解为一组带着奇怪复杂形状的数据。而Flow本意为“流”，二者组成TensorFlow顾名思义解释为<strong>张量流</strong>。</p><p>也就是说，我们可以吧机器学习模型的运行看成一些<strong>张量</strong>组成的<strong>流</strong>。</p><p>这样讲还是很抽象，不过经过下面对各种shape的解释之后就很容易理解了。</p><h2 id="shape"><a href="#shape" class="headerlink" title="shape"></a>shape</h2><p>shape在keras中是一个<code>turple</code>。</p><p><code>shape=(30,4,10) means</code> 意味着一个三维数组：</p><ul><li>维度1 - 30长度</li><li>维度2 - 4长度</li><li>维度3 - 10长度</li></ul><p>对于特定的层来说，可以去参考文档。这里列举几个常用的玩意儿。</p><blockquote><ul><li>Dense layers: (batch_size, input_size)<br>or (batch_size, optional,…,optional, input_size)</li><li>2D convolutional layers:<br>  if using channels_last: (batch_size, imageside1, imageside2, channels)<br>  if using channels_first: (batch_size, channels, imageside1, imageside2)</li><li>1D convolutions and recurrent layers: (batch_size, sequence_length, features)</li></ul></blockquote><p><a href="https://stackoverflow.com/a/50235563/2097240">Details on how to prepare data for recurrent layers</a></p><p>一般来说就是<code>(batch_size, bulabula)</code></p><h2 id="问题：第一层的Dense-unit-…-和input-shape有啥区别呢？"><a href="#问题：第一层的Dense-unit-…-和input-shape有啥区别呢？" class="headerlink" title="问题：第一层的Dense(unit,…)和input_shape有啥区别呢？"></a>问题：第一层的Dense(unit,…)和input_shape有啥区别呢？</h2><p>这就体现出最初的顾名思义TensorFlow了。</p><p><img src="https://gitee.com/songz7026/image-pool/raw/master/Python/Keras_unit_inputshape.jpg" alt="本图片非原创，来源于参考链接"></p><p>对于</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Dense</span>(<span class="hljs-params">unit,input_shape,...</span>)</span><br></code></pre></td></tr></table></figure><p><code>unit</code>: 就是该层的单元数，也即该层输出的尺寸。<br><code>input_shape</code>: 其实这个参数和这个层<strong>没什么关系</strong>，它的使命是告诉这个层未来的输入应该是什么样的（这句话像是废话）。下面详细说一说这个<code>input_shape</code>：</p><p>在Keras中，我们定义的都是<code>Layers</code>，也就是各个隐藏层。但是<code>Layers</code>之间的各种复杂关系我们不需要关心，但是在这里我们说一个概念：层之间流动了是<strong>Tensor</strong>，也就是一堆<strong>上一层计算得到</strong>的复杂形状的数据流给<strong>下一层</strong>供接下来计算。</p><p><strong>我们定义的第一个Layers其实并不是输入层(Input Layer), 而是第一个隐藏层(hidden layer 1)。</strong></p><p>因此在此之前的输入层到第一隐藏层的<strong>Tensor</strong>是Keras接触不到的，只能由智慧的你来告诉他，因此才出现了<code>Input</code>层，实际上它是一个<strong>Tensor</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/44747343/keras-input-explanation-input-shape-units-batch-size-dim-etc">Stack overflow: Keras input explanation: input_shape, units, batch_size, dim, etc</a></p>]]></content>
    
    
    <categories>
      
      <category>TensorFlow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Keras</tag>
      
      <tag>TensorFlow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构：二叉树的遍历</title>
    <link href="/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2021/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构：二叉树的遍历"><a href="#数据结构：二叉树的遍历" class="headerlink" title="数据结构：二叉树的遍历"></a>数据结构：二叉树的遍历</h1><p>相比线性数据类型，树本身是一种递归结构，因此可以有多种方式遍历。<br>树之节点的遍历可以分为三个步骤</p><blockquote><p>对当前节点进行操作（访问）<br>去往左子节点遍历<br>去往右子节点遍历</p></blockquote><p>二叉树的遍历一般可以分为深度优先遍历和广度优先遍历。</p><h2 id="1-深度优先遍历"><a href="#1-深度优先遍历" class="headerlink" title="1. 深度优先遍历"></a>1. 深度优先遍历</h2><p>深度优先遍历由上述三个步骤的先后顺序不同又可以分为：前序、中序、后序遍历</p><ul><li>前序遍历：根节点访问——去左子节点——去右子节点</li><li>中序遍历：去左子节点——根节点访问——去右子节点</li><li>后序遍历：去左子节点——去右子节点——根节点访问</li></ul><p>其实可以看成，是以根节点的位置命名的前、中、后序遍历。</p><p>前序遍历</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Sorted_binary_tree_preorder.svg/330px-Sorted_binary_tree_preorder.svg.png" alt="前序遍历.png"></p><p>中序遍历</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Sorted_binary_tree_inorder.svg/330px-Sorted_binary_tree_inorder.svg.png" alt="中序遍历.png"></p><p>后序遍历</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Sorted_binary_tree_postorder.svg/330px-Sorted_binary_tree_postorder.svg.png" alt="后序遍历.png"></p><p>其中黑点代表在此访问该节点</p><h2 id="2-广度优先遍历（按层次遍历）"><a href="#2-广度优先遍历（按层次遍历）" class="headerlink" title="2. 广度优先遍历（按层次遍历）"></a>2. 广度优先遍历（按层次遍历）</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/Sorted_binary_tree_breadth-first_traversal.svg/330px-Sorted_binary_tree_breadth-first_traversal.svg.png" alt="层次遍历.png"></p><p><strong>参考</strong>：<br><a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86</a><br><a href="https://blog.csdn.net/My_Jobs/article/details/43451187">https://blog.csdn.net/My_Jobs/article/details/43451187</a>_</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在终端中打印多样化文字</title>
    <link href="/2021/02/22/%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%AD%E6%89%93%E5%8D%B0%E5%A4%9A%E6%A0%B7%E5%8C%96%E6%96%87%E5%AD%97/"/>
    <url>/2021/02/22/%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%AD%E6%89%93%E5%8D%B0%E5%A4%9A%E6%A0%B7%E5%8C%96%E6%96%87%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="在终端中打印多样化文字"><a href="#在终端中打印多样化文字" class="headerlink" title="在终端中打印多样化文字"></a>在终端中打印多样化文字</h1><p>先给出几种环境下的解决方案：</p><p>在Python中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">&quot;\033[31;43;1mError!\033[0m&quot;</span>)<br></code></pre></td></tr></table></figure><p>在shell中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;\e[31;43;1mError\!\e[0m&quot;<br><span class="hljs-meta">#</span><span class="bash"> 或</span><br>echo -e &quot;\e[31;43;1mError\!\e[0m&quot;<br><span class="hljs-meta">#</span><span class="bash"> -e 参数用于启用 <span class="hljs-built_in">echo</span> 命令控制符转码</span><br></code></pre></td></tr></table></figure><p>在C++中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>:<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\033[31;43;1m&quot;</span> &lt;&lt; <span class="hljs-string">&quot;Error!&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\033[0m&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>:<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure><p>可以看出在多种环境下，解决这个问题的方案基本上没有区别，因为终端的字符颜色是用转义序列控制的，是文本模式下的系统显示功能，和具体的语言无关。转义序列是以ESC开头,即用\033来完成（ESC的ASCII码用十进制表示是27，用八进制表示就是033）。</p><p>下面以字符串<code>&#39;\e[31;43;1mError!\e[0m&#39;</code>为例说明：</p><p>开头的<code>\e[31;43;1m</code>符号释义：</p><ul><li><p><code>\e</code>: 代表开始ANSI Escape code</p><blockquote><ol><li>ANSI Escape code<br>终端用于文本字符的输入和输出，ASCII编码中有些字符是不能用来打印显示的，比如’\a’ 0x7代表响铃，’\n’ 0x0A 代表换行，这些字符被称为控制符。<br>在此之中，控制符 ‘\e’ 0x1B，这个字符代表 ESC ，即键盘上 ESC 按键的作用。ESC 是单词 escape 的缩写，即逃逸的意思。文本中出现这个转义字符，代表其后方的字符是ANSI Escape code编码。<br>ANSI Escape code编码中有专门控制字符颜色的控制符，例如：\e[37;44;4;1m</li><li>因为 \e 控制符的16进制码为 0x1B ， 8 进制码为 033 ，所以以下表示方式等价：<br>\e[37;44;4;1mMCC\e[0m<br>\x1b[37;44;4;1mMCC\x1b[0m<br>\x1B[37;44;4;1mMCC\x1B[0m<br>\033[37;44;4;1mMCC\033[0m</li></ol></blockquote></li><li><p><code>[</code>: 代表转义序列开始符 CSI，Control Sequence Introducer</p></li><li><p><code>37;44;4;1</code>: 代表以; 分隔的文本样式控制符，其中 37 代表文本前景色为白色，44代表背景为蓝色，4代表下划线，1代表加粗。</p><blockquote><p>由于在 前景色、背景色、显示样式  之中没有重复的值，不会造成混淆，因此放置顺序可以自由调整。而且显示样式也可以使用多个。</p></blockquote></li><li><p><code>m</code>: 代表结束控制符序列</p></li></ul><p>结尾的<code>\e[0m</code>字符释义</p><ul><li><code>\e</code>: 代表开始ANSI Escape code</li><li><code>[</code>: 代表转义序列开始符 CSI，Control Sequence Introducer</li><li><code>0</code>: 代表重置文本样式——说明样式自定义到此结束，后边使用默认样式，不再适用前面的定义</li><li><code>m</code>: 代表结束控制符序列</li></ul><p>总结一下，解决方案分为三部分：<code>&quot;前缀 文本 后缀&quot;</code>（中间不必有空格）</p><p>测试：</p><p><img src="https://gitee.com/songz7026/image-pool/raw/master/Python/%E7%BB%88%E7%AB%AF%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA.jpg" alt="终端彩色输出"></p><p>下面简要概括（搬运）一下可选的样式参数</p><table><thead><tr><th>显示方式</th><th>效果</th><th>前景色</th><th>背景色</th><th>颜色描述</th></tr></thead><tbody><tr><td>0</td><td>终端默认设置</td><td>30</td><td>40</td><td>黑色</td></tr><tr><td>1</td><td>高亮显示（加粗）</td><td>31</td><td>41</td><td>红色</td></tr><tr><td>4</td><td>使用下划线</td><td>32</td><td>42</td><td>绿色</td></tr><tr><td>5</td><td>闪烁</td><td>33</td><td>43</td><td>黄色</td></tr><tr><td>7</td><td>反白显示</td><td>34</td><td>44</td><td>蓝色</td></tr><tr><td>8</td><td>不可见</td><td>35</td><td>45</td><td>紫红色</td></tr><tr><td>22</td><td>非高亮显示</td><td>36</td><td>46</td><td>青蓝色</td></tr><tr><td>24</td><td>去下划线</td><td>37</td><td>47</td><td>白色</td></tr><tr><td>25</td><td>去闪烁</td><td></td><td></td><td></td></tr><tr><td>27</td><td>非反白显示</td><td></td><td></td><td></td></tr><tr><td>28</td><td>可见</td><td></td><td></td><td></td></tr></tbody></table><p>参考文章中有对可选参数十分详细的介绍，[3]中尤为详细。</p><p><strong>参考</strong><br>[1]. <a href="https://blog.csdn.net/wls666/article/details/100867234?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=c8f28b2e-ba9c-4134-89a4-73aaf8ed5c40&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">python中print打印显示颜色</a><br>[2]. <a href="https://leojhonsong.github.io/zh-CN/2019/09/12/Linux%E7%BB%88%E7%AB%AF%E5%91%88%E7%8E%B0%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/">Linux终端呈现彩色输出</a><br>[3]. <a href="https://segmentfault.com/a/1190000012666612">在终端中输出彩色文字</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>终端</tag>
      
      <tag>打印样式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python异常检测开源工具包</title>
    <link href="/2021/02/15/Python%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    <url>/2021/02/15/Python%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="异常检测的工具包PyOD"><a href="#异常检测的工具包PyOD" class="headerlink" title="异常检测的工具包PyOD"></a>异常检测的工具包PyOD</h1><p><a href="https://github.com/yzhao062/pyod">GitHub项目地址</a><br><a href="https://pyod.readthedocs.io/en/latest/">文档地址</a></p><p><code>PyOD</code>是在<code>sklearn</code>基础上开发的异常检测工具包，<a href="https://pyod.readthedocs.io/en/latest/#implemented-algorithms">涉及到的检测方法</a>分为三类：</p><ol><li>Individual Detection Algorithms</li><li>Outlier Ensembles &amp; Outlier Detector Combination Frameworks</li><li>Utility Functions</li></ol><p>美中不足在于所涉及的所有算法均是<code>offline</code>模式，无法满足增量学习（在线学习）的测试需求。（尽管部分模型中存在<code>partial_fit()</code>方法）</p><h1 id="增量学习（在线学习）的异常检测工具包PySAD"><a href="#增量学习（在线学习）的异常检测工具包PySAD" class="headerlink" title="增量学习（在线学习）的异常检测工具包PySAD"></a>增量学习（在线学习）的异常检测工具包PySAD</h1><p><a href="https://github.com/selimfirat/pysad">GitHub项目地址</a><br><a href="https://pysad.readthedocs.io/en/latest/">文档地址</a></p><p><code>PySAD</code>也是在<code>sklearn</code>基础上开发的异常检测工具包，同时也向<code>PyOD</code>兼容，<a href="https://pysad.readthedocs.io/en/latest/examples.html#example-pyod-integration">提供了与PyOD协作的方法</a>。</p><p><a href="https://pysad.readthedocs.io/en/latest/api.html#api-reference">涉及到的检测方法</a>可以从官方的API文档中查看。</p><h1 id="兼顾离线学习于在线学习的检测工具包alibi-detect"><a href="#兼顾离线学习于在线学习的检测工具包alibi-detect" class="headerlink" title="兼顾离线学习于在线学习的检测工具包alibi-detect"></a>兼顾离线学习于在线学习的检测工具包alibi-detect</h1><p><a href="https://github.com/SeldonIO/alibi-detect">GitHub项目地址</a><br><a href="https://docs.seldon.io/projects/alibi-detect/en/latest/">文档地址</a></p><p>并未经过实际测试应用，了解不多。</p><p>需要更多详情可以参考项目仓库和文档。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>日积月累</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python将list中str转换为数字 —— map()函数使用方法</title>
    <link href="/2021/02/15/Python%E5%B0%86list%E4%B8%ADstr%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E2%80%94%E2%80%94map()%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2021/02/15/Python%E5%B0%86list%E4%B8%ADstr%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E2%80%94%E2%80%94map()%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Python将list中str转换为数字-——-map-函数使用方法"><a href="#Python将list中str转换为数字-——-map-函数使用方法" class="headerlink" title="Python将list中str转换为数字 —— map()函数使用方法"></a>Python将list中str转换为数字 —— map()函数使用方法</h1><h2 id="问题：list中str转换为数字"><a href="#问题：list中str转换为数字" class="headerlink" title="问题：list中str转换为数字"></a>问题：list中str转换为数字</h2><p>问题描述：若在数据处理过程中，遇到一个list变量</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;23&#x27;</span>, <span class="hljs-string">&#x27;43&#x27;</span>, <span class="hljs-string">&#x27;24&#x27;</span>]</span><br></code></pre></td></tr></table></figure><p>其中的元素都为<code>str</code>类型，但数据处理需要数字类型，因此需要做进一步转化</p><p>我们利用迭代映射函数<code>map()</code>，先看一下<code>map()</code>函数的功能：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">map</span>(<span class="hljs-params">function, iterable, ...</span>)</span><br></code></pre></td></tr></table></figure><ul><li><code>function</code>, 对后边对象需要进行的操作</li><li><code>iterable</code>, 希望被操作的对象</li></ul><p><strong>注意</strong>：<code>map()</code>函数在Python 2和Python 3中存在微小的差别：</p><ul><li>Python 2返回操作后得到的list</li><li>Python 3返回迭代器</li></ul><p>结合当前问题体会一下<code>map()</code>函数的操作</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"># Python 2<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;23&#x27;</span>, <span class="hljs-string">&#x27;43&#x27;</span>, <span class="hljs-string">&#x27;24&#x27;</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,a)</span><br>[2, 23, 43, 24]<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>,a)</span><br>[2.0, 23.0, 43.0, 24.0]<br><br># Python 3: 需要使用list将map()返回的迭代器转换为list对象<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;23&#x27;</span>, <span class="hljs-string">&#x27;43&#x27;</span>, <span class="hljs-string">&#x27;24&#x27;</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,a))</span><br>[2, 23, 43, 24]<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>,a))</span><br>[2.0, 23.0, 43.0, 24.0]<br></code></pre></td></tr></table></figure><p>相当于对<code>a</code>中每一个元素都进行了<code>int(x)</code>/<code>float(x)</code>操作</p><h2 id="map-函数的引申使用"><a href="#map-函数的引申使用" class="headerlink" title="map()函数的引申使用"></a>map()函数的引申使用</h2><p>我们可以利用<code>map()</code>进行更多自定义操作</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">b=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]</span><br><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">x</span>):</span></span><br>return x+1<br><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(fun,b))</span><br>[2, 3, 4, 5]<br># 或使用lambda匿名函数<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x+<span class="hljs-number">2</span>,b))</span><br>[3, 4, 5, 6]<br><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">c = [<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x, y: x + <span class="hljs-number">2</span> * y, b, c))</span><br>[15, 14, 11, 10]<br></code></pre></td></tr></table></figure><p><strong>参考</strong></p><p><a href="https://www.runoob.com/python/python-func-map.html">Python map() 函数</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>日积月累</tag>
      
      <tag>map()</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python获取list特定元素下标</title>
    <link href="/2021/02/15/Python%E8%8E%B7%E5%8F%96list%E7%89%B9%E5%AE%9A%E5%85%83%E7%B4%A0%E4%B8%8B%E6%A0%87/"/>
    <url>/2021/02/15/Python%E8%8E%B7%E5%8F%96list%E7%89%B9%E5%AE%9A%E5%85%83%E7%B4%A0%E4%B8%8B%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="python获取list特定元素下标"><a href="#python获取list特定元素下标" class="headerlink" title="python获取list特定元素下标"></a>python获取list特定元素下标</h1><p>反索引，一般情况我们通过索引获取list中的元素。<br>如：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a[<span class="hljs-number">3</span>]</span><br>4<br></code></pre></td></tr></table></figure><p>有些时候，我们已知list中的某些元素，但需要通过已知元素获得其在list中的索引位置。</p><h2 id="方法1：利用builtin方法item-index-list"><a href="#方法1：利用builtin方法item-index-list" class="headerlink" title="方法1：利用builtin方法item.index(list)"></a>方法1：利用builtin方法item.index(list)</h2><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a.index(<span class="hljs-number">3</span>)</span><br>2<br></code></pre></td></tr></table></figure><p><strong>注意</strong> 如果list中存在重复值，这个方法只能获得第一个值的index。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a.index(<span class="hljs-number">2</span>)</span><br>0<br></code></pre></td></tr></table></figure><h2 id="方法2：enumerate-方法"><a href="#方法2：enumerate-方法" class="headerlink" title="方法2：enumerate()方法"></a>方法2：enumerate()方法</h2><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">e=<span class="hljs-built_in">enumerate</span>(a)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">e</span><br>&lt;enumerate object at 0x000001A6FF29D7C0&gt;<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">list</span>(e)</span><br>[(0, 2), (1, 1), (2, 3), (3, 2), (4, 6)]<br></code></pre></td></tr></table></figure><p>不难发现，<code>enumerate()</code>方法包含的值的形式为</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">(<span class="hljs-keyword">index</span> <span class="hljs-number">0</span>, value <span class="hljs-number">0</span>),(<span class="hljs-keyword">index</span> <span class="hljs-number">1</span>, value <span class="hljs-number">1</span>),(<span class="hljs-keyword">index</span> <span class="hljs-number">2</span>, value <span class="hljs-number">2</span>)...<br></code></pre></td></tr></table></figure><p>可以通过利用这个信息获得元素的index</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">print([i <span class="hljs-keyword">for</span> i,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a) <span class="hljs-keyword">if</span> x==<span class="hljs-number">2</span>])</span><br>[0, 3]<br></code></pre></td></tr></table></figure><p><strong>参考</strong><br><a href="https://blog.csdn.net/qq_24737639/article/details/78839678">python 获取list特定元素下标</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>日积月累</tag>
      
      <tag>list查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础笔记</title>
    <link href="/2021/02/15/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/02/15/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java语言基础笔记"><a href="#Java语言基础笔记" class="headerlink" title="Java语言基础笔记"></a>Java语言基础笔记</h1><h3 id="interface-￼接口"><a href="#interface-￼接口" class="headerlink" title="interface ￼接口"></a>interface ￼接口</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">￼[可见度] <span class="hljs-keyword">interface</span> 接口名称 <span class="hljs-symbol">extend</span> 其他接口&#123;<br><span class="hljs-comment">// 声明变量</span><br><span class="hljs-comment">// 抽象方法</span><br>&#125; <br></code></pre></td></tr></table></figure><p>interface接口可以理解为一种特殊的抽象类，对抽象类进一步特殊化，是抽象方法的集合。</p><p>接口不可以被*<strong>实例化**<em>，但可以被</em></strong>实现***。但是Java 8之后改进为允许定义默认方法和实现<br>更过详见gitee的wiki——《抽象类与接口》</p><h3 id="container-容器"><a href="#container-容器" class="headerlink" title="container 容器"></a>container 容器</h3><p>container内容比较复杂，简单来说，是Java为开发者提前造好的轮子，就字面意思理解为==存放数据的容器==，解决基本数据类型（如数组）不能解决的问题。</p><p>此外还会涉及到数据结构、线程安全等的问题。</p><p>常用的部分container</p><blockquote><p>Collection **==元素==**的集合</p><blockquote><p>一、List 元素可重复</p></blockquote></blockquote><p><code>List.toArray()把List转化为Array（Object数组）</code></p><blockquote><blockquote><blockquote><p><del>1. Vector：已经被弃用(From JDK1.5)，<strong>线程同步</strong></del></p><blockquote><p><del>Stack：是满足后进先出的容器，但LinkedList可以实现所有栈功能</del></p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><ol start="2"><li>ArrayList：可以<strong>动态增长</strong>的数组，默认长度是10。<br>随机访问快，插入删除慢。</li><li><strong>LinkedList：同时属于Collection和Queue）</strong> ：用<strong>链表</strong>实现的容器。<strong>可以实现很多队列、栈的数据结构。</strong><br>查找慢（遍历整个链表），插入删除快。</li></ol></blockquote></blockquote></blockquote><blockquote><blockquote><p>二、Queue 队列 先进后出FILO</p><blockquote><p><strong>LinkedList （同时属于Collection和Queue）</strong><br>PriorityQueue 优先级队列</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>三、Set 集合 元素不可重复</p><blockquote><ol><li>HashSet：底层使用散列函数，查询方面有优化<blockquote><p> LinkHashSet</p></blockquote></li></ol></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><ol start="2"><li>TreeSet：底层使用红黑树</li></ol></blockquote></blockquote></blockquote><blockquote><p>Map **==键值对==**的集合</p><blockquote><ol><li>HashMap 适合查找、删除、插入</li><li>TreeMap 适合遍历</li></ol></blockquote></blockquote><p>上述表述极不全面，待补充。</p><h3 id="多态Polymorphism"><a href="#多态Polymorphism" class="headerlink" title="多态Polymorphism"></a>多态Polymorphism</h3><p>多态指的是一个<strong>引用</strong>变量在程序中可以充当多种角色。细化地讲，比如可以将一个类的引用变量赋值为其子类的实例，如代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Animal.class是Cat.class Pig.class的* 父类</span><br><span class="hljs-comment">*/</span><br>Animal an1;<br>Animal an2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Animal</span>();<br>Animal an3 = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();<br>Animal an4 = <span class="hljs-keyword">new</span> <span class="hljs-type">Pig</span>();<br></code></pre></td></tr></table></figure><p>在多态问题中，还存在函数调用的问题：</p><ul><li>如上例语句3中，an3只能调用Animal的方法，因为不能保证Animal中有子类的方法。只有声明部分明确声明为子类类型时，其引用变量才能调用对应子类的方法</li><li><strong>动态调用</strong>问题：若子类和父类同时含有相同名称的方法，默认调用最能体现具体特点的子类方法。</li></ul><p>instanceof运算符能判断具体的实例是否满足某个特定的类型。</p><h3 id="异常Exception"><a href="#异常Exception" class="headerlink" title="异常Exception"></a>异常Exception</h3><h5 id="异常的介绍"><a href="#异常的介绍" class="headerlink" title="异常的介绍"></a>异常的介绍</h5><p>Java中所有能被抛出的对象都视为Throwable类的实例，Exception和Error都是Throwable类的子类。<br>其中：</p><ul><li>Error表示程序遇到的严重错误，几乎无法挽回。</li><li>Exception程度轻一点，比如打开一个不存在的文件。</li></ul><p>进一步地，Java将运行时异常(RuntimeException)定性为非检查性异常(unchecked exceptions)，而所有其它异常定性为检查性异常(checked exceptions)。<br><strong>前者</strong>在运行时出现，由于运行程序的各种不可预见性，所以称之为“unchecked”。<br><strong>后者</strong>在程序开发中可预见，因此称之为“checked”（有些不运行就难以发现的异常也是checked异常）。</p><p>可以通过继承来定义新的异常类型。</p><h5 id="异常的抛出与处理"><a href="#异常的抛出与处理" class="headerlink" title="异常的抛出与处理"></a>异常的抛出与处理</h5><p>在异常问题中，事件的主体有两个：</p><ul><li>代码：代码中可以编写有效获取并处理异常的程序。</li></ul><p>代码主动进行异常抛出使用<code>throw new ExceptionType();</code><br>在函数声明时也可以使用<code>throws</code>来声明此函数可能抛出的异常类别：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">abc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException,NullPointerException</span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>JVM：当出现代码中未处理的异常时，JVM会在打印运行时的堆栈跟踪信息之后终止程序的运行。如下段代码所示（例）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> &quot;<span class="hljs-selector-tag">main</span>&quot; <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NullPointerException</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.toArray</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:358)</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">net</span><span class="hljs-selector-class">.datastructures</span><span class="hljs-selector-class">.HashChainMap</span><span class="hljs-selector-class">.bucketGet</span>(<span class="hljs-selector-tag">HashChainMap</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:35)</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">net</span><span class="hljs-selector-class">.datastructures</span><span class="hljs-selector-class">.AbstractHashMap</span><span class="hljs-selector-class">.get</span>(<span class="hljs-selector-tag">AbstractHashMap</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:62)</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">dsaj</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.Demonstration</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">Demonstration</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:12)</span><br></code></pre></td></tr></table></figure><p>需要注意的是，在堆栈的跟踪信息中，每一步都有机会获取(catch)和处理异常，下级未处理的异常会被传递给上级调用函数，当异常层层上报都没有被有效处理，JVM就要插手打印信息并终止程序。<br>JVM在不经过代码时也可能抛出异常（如堆栈溢出）。</p><p>正确的异常处理方法为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span>&#123;<br>expressions;<br>&#125; <span class="hljs-keyword">catch</span>(EXCEPTIONtype1 e)&#123;<br>expressions;<br>&#125; <span class="hljs-keyword">catch</span>(EXCEPTIONtype2 e)&#123;<br>expressions;<br>&#125; <span class="hljs-keyword">catch</span>(EXCEPTIONtype3 e)&#123;<br>expressions;<br>&#125;...<br>...<br>final&#123;<br>expressions;<br>&#125;<br></code></pre></td></tr></table></figure><p> 值得注意的是，从JDK SE 7开始，允许catch中异常类型的合并：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><br><span class="hljs-keyword">try</span>&#123;<br>expressions;<br>&#125; <span class="hljs-keyword">catch</span>(EXCEPTIONtype1| EXCEPTIONtype2| EXCEPTIONtype3 e)&#123;<br>expressions;<br>&#125;<br>...<br><span class="hljs-keyword">final</span>&#123;<br>expressions;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样是从JDK SE7开始，尝试了一种新的“try with resource”(尚未研究，略）</p><h3 id="强制类型转换与泛型"><a href="#强制类型转换与泛型" class="headerlink" title="强制类型转换与泛型"></a>强制类型转换与泛型</h3><h4 id="强制类型转换Casting"><a href="#强制类型转换Casting" class="headerlink" title="强制类型转换Casting"></a>强制类型转换Casting</h4><p>主要关注引用类型的强制类型转换问题，一般包含两个子问题：</p><ul><li>widening casting：<strong>具体-&gt;抽象</strong>，向上转换</li></ul><p>从 <strong>低层次</strong> 类型T转换为 <strong>高层次</strong> 类型U。一般有以下三种情况：</p><blockquote><p>子类对象T 转换为 父类对象U<br>子接口T 转换为 父接口U<br>T使用了接口U</p></blockquote><p><em>类似多态问题</em></p><ul><li>narrow casting ：<strong>抽象-&gt;具体</strong>，向下转换</li></ul><p>从 <strong>高层次</strong> 类型T转换为 <strong>低层次</strong> 类型U。一般有以下三种情况：</p><blockquote><p>父类对象T 转换为 子类对象U<br>父接口T 转换为 子接口U<br>U使用了接口T</p></blockquote><p>一般来说，向上转换比较安全，编译器可以自动认定转换的正确性，但向下转换不行。</p><p>因此产生了运算符**<code>instanceof</code>**，语法为</p><p><strong><code>Obj instanceof Type</code></strong></p><p>当强制转换出现问题时，会出现<code>ClassCastException</code>异常</p><h4 id="泛型Generics"><a href="#泛型Generics" class="headerlink" title="泛型Generics"></a>泛型Generics</h4><p>泛型产生的对应需求是，需要将同一类功能实现到不同类型的数据上，而不针对每个特定的类型都造出重复的车轮子。</p><ul><li>泛型的前世</li></ul><p>泛型时自Java SE 5才开始有的，在此之前，使用Object类进行相似功能，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>Object A;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(Object a)</span></span>&#123;<br>A = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Method</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> A;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于Object的所有类型的父类（超类），因此可以接受所有类型的向上强制类型转换，所以看上去是个很好的选择，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br>String str = “hello”<br><span class="hljs-keyword">public</span> Test test = <span class="hljs-keyword">new</span> Test(str);<br>String ret = test.Method();<br>...<br></code></pre></td></tr></table></figure><p>上述代码的初衷在于使用一个String类型创建一个Test实例test，然后获取其中存储的内部变量赋值给String对象ret。</p><p>但事实上，这是不安全的甚至编译不会通过，因为在最后一行代码中，涉及到了将test对象内部存储的Object对象test.A向下转换到类型String，因此需要显示强制类型转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">String ret = (String) test.Method();<br></code></pre></td></tr></table></figure><ul><li>Java SE 5 之后到泛型</li></ul><p>泛型支持在类型定义中使用参数化的类型定义变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>T A;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(Object a)</span></span>&#123;<br>A = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Method</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> A;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，声明了一个参数化类型T，并且在内部代码中视为一个已知类型使用，在实例化和后续使用时，如示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br>String str = “hello”<br><span class="hljs-keyword">public</span> Test&lt;String&gt; test;<br>test = <span class="hljs-keyword">new</span> Test&lt;String&gt;(str);<span class="hljs-comment">// 可选1</span><br>test = <span class="hljs-keyword">new</span> Test&lt;&gt;(str);<span class="hljs-comment">// 可选2</span><br>String ret = test.Method();<br>...<br></code></pre></td></tr></table></figure><p>上述代码中，声明Test类型的实例test时，指定了Test内部的参数化类型为String，因此在实例test内部将T类型视为String类型，所以对于方法test.Method()返回的也自然就是String类型的对象，不需要进行类型转换了。</p><p>按照代码书写惯例，参数化类型一般采用单个大写字母。</p><p>需要注意的是，代码中“可选1”和“可选2”是两种实例化方法，最初是使用“可选1”的风格。在Java SE 7之后为了简化，采用了“可选2”的风格，这种风格也常被称为“菱形语法”，赋值时自动匹配待赋值引用变量声明时所规定的泛型类型。</p><p>如果没有指定类型<code>test = new Test(str)</code>，则视为使用经典类型（Java SE 5 之前），泛型被视为指定成Object类型</p><p>泛型不接受基本类型的制定，如double需要制定为其包装类型Double。</p><ul><li>泛型与数组联合使用的风险</li></ul><p>泛型对象和数组一起使用时存在不安全的风险，具体来讲，Java允许使用带泛型的数组声明，但是不允许在实例化(new)的时候生成泛型实例直接赋值给数组。可以接受的折衷办法是使用旧版方法（不使用菱形语法）然后经过强制类型转换赋值给对应数组，尽管此办法可行，但编译时仍会报出warning，因为这是不安全的。一般以下两种情况会遇到此风险。</p><p>-&gt; 外部创建泛型类的数组</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Test&lt;A&gt;<span class="hljs-comment">[]</span> tests<br>tests = new Test&lt;A&gt;<span class="hljs-comment">[10]</span>;<span class="hljs-comment">[错]</span><br>tests = new Test<span class="hljs-comment">[10]</span>;<span class="hljs-comment">[对]</span><br>tests<span class="hljs-comment">[0]</span> = new Test&lt;A&gt;;<span class="hljs-comment">[对]</span><br></code></pre></td></tr></table></figure><p>-&gt; 泛型类内部创建泛型类数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">A</span>&gt;</span>&#123;<br>A[] a;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Test</span>(<span class="hljs-params"></span>)</span>&#123;<br>a = <span class="hljs-keyword">new</span> A[<span class="hljs-number">10</span>];[错]<br>a = (A[]) <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>[<span class="hljs-number">10</span>][对]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法中使用泛型</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Test()<span class="hljs-comment">&#123;</span><br><span class="hljs-comment">public &lt;A&gt; void method(A[] a)&#123;</span><br><span class="hljs-comment">A temp=a[0];</span><br><span class="hljs-comment">&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>限定泛型范围</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-title">&lt;A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExistClass&gt;</span></span><br></code></pre></td></tr></table></figure><p>将泛型A可以指定的类型范围强制限定为某个已知的类型范围内，保证内部某些方法的可用性。</p><h3 id="反射Reflect"><a href="#反射Reflect" class="headerlink" title="反射Reflect"></a>反射Reflect</h3><p>代码引入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//对于一个类Test</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-comment">//定义方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method4</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-comment">//定义构造器</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br>Test()&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-comment">//定义属性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> d = <span class="hljs-number">2.1</span>;<br>&#125;<br><br><span class="hljs-comment">//正常使用</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test01</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>Test test = <span class="hljs-keyword">new</span> Test();<br>test.method1(); <br>&#125;<br>&#125;<br><span class="hljs-comment">//使用反射</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test02</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>Class cls = Class.forName(“com.xxx.xxx.Test”);<br>Object o = cls.newInstance();<br>Method m1 = c.getMethod(“Method01”);<br>m1.invoke(o);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>乍一看很蒙，这就是反射的第一印象，这东西不理解的时候看起来很蒙，理解之后看起来就很容易懂了。</p><h4 id="反射的理解层面"><a href="#反射的理解层面" class="headerlink" title="反射的理解层面"></a>反射的理解层面</h4><h4 id="反射的具体使用"><a href="#反射的具体使用" class="headerlink" title="反射的具体使用"></a>反射的具体使用</h4><h5 id="获取Class类对象（字节码信息）的几种方法"><a href="#获取Class类对象（字节码信息）的几种方法" class="headerlink" title="获取Class类对象（字节码信息）的几种方法"></a>获取Class类对象（字节码信息）的几种方法</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//方式1:通过具体实例对象的getClass()方法</span><br>Test test1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Test()</span>;<br>Class cls1 = test1.get<span class="hljs-constructor">Class()</span>;<br><span class="hljs-comment">//方式2:通过具体类的内置静态class属性</span><br>Class cls2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span><span class="hljs-keyword">class</span>;<br><span class="hljs-comment">//方式3:通过Class类的静态方法forName()方法[- 最常用 -]</span><br>Class cls3 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(“<span class="hljs-params">com</span>.<span class="hljs-params">xxx</span>.<span class="hljs-params">xxx</span>.Test”)</span>;<br><span class="hljs-comment">//方式4:通过类的加载器</span><br>ClassLoader cloader = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">ClassLoader()</span>; <br>Class cls4 = loader.load<span class="hljs-constructor">Class(“<span class="hljs-params">com</span>.<span class="hljs-params">xxx</span>.<span class="hljs-params">xxx</span>.Test”)</span>;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>若判断<code>cls1==...==cls4</code>会返回<code>true</code>，因为他们都代表同一个类别Test的字节码。</li><li>方法3是最常用的，用于动态指定操作的类、对象、方法等。由于其他三种方法中都已经包含指定特定的类、对象、方法进行操作，一般不会应用到反射的最大应用场景——动态指定类和对象。</li></ul><h5 id="获取类的构造器以及对象的创建"><a href="#获取类的构造器以及对象的创建" class="headerlink" title="获取类的构造器以及对象的创建"></a>获取类的构造器以及对象的创建</h5><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">Class</span> c = <span class="hljs-keyword">Class</span>.forName(“com.xxx.xxx.Test”);<br><br><span class="hljs-comment">//获取包括其父类在内的所有public构造器</span><br><span class="hljs-function"><span class="hljs-keyword">Constructor</span>[] <span class="hljs-title">cons</span> = <span class="hljs-title">c</span>.<span class="hljs-title">getConstructors</span><span class="hljs-params">()</span>;</span><br><span class="hljs-comment">//获取包括其父类在内的所有构造器（不局限于public）</span><br><span class="hljs-comment">//public protected default private都可以获取到</span><br><span class="hljs-function"><span class="hljs-keyword">Constructor</span>[] <span class="hljs-title">cons</span> = <span class="hljs-title">c</span>.<span class="hljs-title">getDeclaredConstructors</span><span class="hljs-params">()</span>;</span><br><br><span class="hljs-comment">//获取特定构造器</span><br><span class="hljs-comment">//若需要获取的构造器非pubilc，需要使用getDeclaredConstructor(&lt;Class&gt;);</span><br><span class="hljs-comment">//根据参数列表区分不同构造器</span><br><span class="hljs-function"><span class="hljs-keyword">Constructor</span> <span class="hljs-title">cons1</span> = <span class="hljs-title">c</span>.<span class="hljs-title">getConstructor</span><span class="hljs-params">(int.<span class="hljs-keyword">class</span>, double.<span class="hljs-keyword">class</span>, SpecificClass)</span>;</span><br><br><span class="hljs-comment">//创建对象：使用构造器创建对象</span><br><span class="hljs-keyword">Object</span> o = cons1.newInstance();<br><br></code></pre></td></tr></table></figure><h5 id="获取类的属性和赋值"><a href="#获取类的属性和赋值" class="headerlink" title="获取类的属性和赋值"></a>获取类的属性和赋值</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Class c = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(“<span class="hljs-params">com</span>.<span class="hljs-params">xxx</span>.<span class="hljs-params">xxx</span>.Test”)</span>;<br><br>Field<span class="hljs-literal">[]</span> feilds = c.get<span class="hljs-constructor">Feilds()</span>;<br>Field age = c.get<span class="hljs-constructor">Feild(“<span class="hljs-params">age</span>”)</span>;<br><span class="hljs-comment">//同理若需要非public属性时</span><br>Field<span class="hljs-literal">[]</span> feilds = c.get<span class="hljs-constructor">DeclaredFeilds()</span>;<br>Field size = c.get<span class="hljs-constructor">DeclaredFeild(“<span class="hljs-params">bombsize</span>”)</span>;<br><br><span class="hljs-comment">//还可以获取属性的修饰符、数据类型……</span><br><br>size.get<span class="hljs-constructor">Modifiers()</span>;<br>size.get<span class="hljs-constructor">Name()</span>;<br>size.get<span class="hljs-constructor">Type()</span>;<br><br><span class="hljs-comment">//给属性赋值</span><br>size.set(??,<span class="hljs-number">34</span>);<span class="hljs-comment">//Error!</span><br><br>Object oset = cons1.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>size.set(oset, <span class="hljs-number">34</span>);<span class="hljs-comment">//valid</span><br></code></pre></td></tr></table></figure><h5 id="获取类的方法和调用"><a href="#获取类的方法和调用" class="headerlink" title="获取类的方法和调用"></a>获取类的方法和调用</h5><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Class</span> c = <span class="hljs-keyword">Class</span>.forName(“com.xxx.xxx.Test”);<br><br><span class="hljs-function"><span class="hljs-keyword">Method</span>[] <span class="hljs-title">m1</span> = <span class="hljs-title">c</span>.<span class="hljs-title">getMethods</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-keyword">Method</span> <span class="hljs-title">m2</span> = <span class="hljs-title">c</span>.<span class="hljs-title">getMethod</span><span class="hljs-params">(“methodName”)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">Object</span> <span class="hljs-title">o</span> = <span class="hljs-title">cons1</span>.<span class="hljs-title">newInstance</span><span class="hljs-params">()</span>;</span><br>m2.Invoke(o);<br></code></pre></td></tr></table></figure><h4 id="反射值得思考的问题"><a href="#反射值得思考的问题" class="headerlink" title="反射值得思考的问题"></a>反射值得思考的问题</h4><ul><li>简而言之，反射的用法很多，功能很强大，除上述用法之外，还可以获得其父类、接口、注解等一系列信息，具体实现方法可以参考API文档。</li><li>反射的规律性，反射的功能很多，但是从规律上而言，大致可以这么看：批量获取所有目标可以调用getXxxs()或者getDeclaredXxxs()方法，获取单个目标可以调用不带s版本的对应方法。获取public目标可以调用getXxxs() 或者getXxx(…)，获取非public目标可以调用对应方法的Declared版本。</li><li>反射是否破坏了面向对象的封装？回答：事实上确实破坏了，但是反射有它自己的实现环境，迎合了一部分需求。应该尽量保持面向对象的封装型，但在一定的需求情况下考虑变通。打个比方，1、男生不能进女厕所，2、女生不能进男生宿舍。</li></ul><h3 id="注解Annotation"><a href="#注解Annotation" class="headerlink" title="注解Annotation"></a>注解Annotation</h3><h4 id="注解的理解层面"><a href="#注解的理解层面" class="headerlink" title="注解的理解层面"></a>注解的理解层面</h4><p>严格来说，注解对程序的逻辑实现没什么用。注解起到的作用是，在程序中充当<strong>提醒</strong>的角色，提醒程序猿、编译器等一系列让程序debug向正常运行方向的主体。<br>比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method1</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的目的是重写某个主体内部的method1()方法。如果程序猿不写@Override，程序也能正常编译，如果逻辑没问题的话正常运行。但是一旦程序猿犯困，嘛method1方法名写错了，如果不写@Override的话，程序会继续创建一个新方法，默默无闻，傻不拉几；如果@Override存在，编译器会发现卧槽，你这方法我以前没见过，怎么重写？是不是你拼错了还是发生了啥？醒醒！</p><h4 id="常用的三个注解"><a href="#常用的三个注解" class="headerlink" title="常用的三个注解"></a>常用的三个注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Override</span><span class="hljs-comment">//重写方法</span><br><span class="hljs-meta">@Deprecated</span><span class="hljs-comment">//标记已经被淘汰的方法</span><br><span class="hljs-meta">@SuppressWarning</span><span class="hljs-comment">//标记以抑制编译器警告</span><br></code></pre></td></tr></table></figure><h4 id="注解的自定义"><a href="#注解的自定义" class="headerlink" title="注解的自定义"></a>注解的自定义</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">public @interface Haha()&#123;<br><span class="hljs-regexp">//</span>看上去是无参数方法，实际上理解成一个成员变量<br><span class="hljs-regexp">//</span>约定俗成如果只有一个无参数方法（）就命名为value<br><span class="hljs-regexp">//</span>String[]成员变量返回值（类型） value成员变量的名称 <br>String[] value();<br><span class="hljs-regexp">//</span>内部定义参数的注解——标记<br><span class="hljs-regexp">//</span>内部没有定义参数的注解——元数据<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java">标记注解的注解——元注解<br><span class="hljs-meta">@Retention</span>注解存活时间：源代码、编译、运行<br><span class="hljs-meta">@Target</span>注解的使用范围：类型、属性、方法……<br><span class="hljs-meta">@Documented</span>注解是否被收入文档<br><span class="hljs-meta">@Inherited</span>继承于被标记的注解也会继承注解<br>相应的参数查看源码即可得<br></code></pre></td></tr></table></figure><h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><p>Java的IO的四大基类<br><img src="https://i.loli.net/2020/11/14/SKMlFCAeRzQb3qH.jpg" alt="Alt"></p><h4 id="File类-java-io-File"><a href="#File类-java-io-File" class="headerlink" title="File类(java.io.File)"></a>File类(java.io.File)</h4><p>File类的理解：将系统中的文件、文件夹抽象为File类（联想到Linux系统中“万物皆文件”），如无特殊说明，本段后续统称文件和文件夹为<strong>文件</strong>。</p><h5 id="File类的基本使用："><a href="#File类的基本使用：" class="headerlink" title="File类的基本使用："></a>File类的基本使用：</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake">/* 创建一个关联于某个路径的<span class="hljs-keyword">file</span>对象<br>* 理解：这里只是在程序中创建了一个对象，对象指向了某个路径。<br>* 至于这个路径到底正确与否、存在与否，至少到这里程序是不关心的。<br>* 相当于在程序中写入了一个地址记录，至于地址到底有没有人，有没有房子，那是以后的事，这里只是在纸上写了一行字<br>* /<br><span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> = new <span class="hljs-keyword">File</span>(“PATH”);<br>// 可以通过这个对象对指定文件进行一系列操作<br><span class="hljs-keyword">String</span> name = <span class="hljs-keyword">file</span>.getName();<br>...<br><br></code></pre></td></tr></table></figure><h5 id="那么这个路径到底对不对呢？"><a href="#那么这个路径到底对不对呢？" class="headerlink" title="那么这个路径到底对不对呢？"></a>那么这个路径到底对不对呢？</h5><p>在程序执行过程中，如果路径出现问题，会报错。<br>一般来说面临两个问题：</p><ol><li>路径拼错了</li><li>对应目录不存在</li></ol><p>对于路径拼错这个问题，双十一重新买双手买个脑子能解决。</p><p>对于对应目录不存在这个问题，如果进行后续操作会遇到问题，比如打开一个不存在的文件，这是比较反智的。因此一般会进行如下操作：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(“PATH”);<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">file</span>.exists())&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">file</span>.createNewFile();<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>System.out.<span class="hljs-keyword">println</span>(“<span class="hljs-keyword">File</span> exists!”);<br><span class="hljs-keyword">file</span>.xxxxx();<br>&#125;<br><br><span class="hljs-comment">//同理：上述代码创建文件，我们也可以创建文件夹</span><br><br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">file</span>.exists())&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">file</span>.mkdir();<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>System.out.<span class="hljs-keyword">println</span>(“Directory exists!”);<br><span class="hljs-keyword">file</span>.xxxxx();<br>&#125;<br><span class="hljs-comment">/* 创建文件夹时，注意到有两个方法：</span><br><span class="hljs-comment">* mkdir()</span><br><span class="hljs-comment">* mkdirs()：可以一次性创建多层文件夹</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>File类关注文件本身，可以操作文件的各种属性。但对于文件内部的具体内容，需要引入流的观念。</p><h5 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h5><h6 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h6><p>“流”可以分为输入输出流，类比物理学的“参考系”说明方法而言，如果以Java程序为参考系，Java获取到的数据就是输入流，Java送出的数据就是输出流。</p><h6 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h6><p>字节流：(Byte Stream)针对二进制类型数据<br>字符流：(Char Stream)针对字符类型数据<br>具体使用字节流还是字符流还是要看要操作什么类型的数据。都是统称，下面还包含很多东西。</p><h6 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h6><p>节点流：直接和操作对象接触<br>处理流：处理已经存在的流（包括节点流和处理流）</p><h4 id="字节流：InputStream接口、OutputStream接口"><a href="#字节流：InputStream接口、OutputStream接口" class="headerlink" title="字节流：InputStream接口、OutputStream接口"></a>字节流：InputStream接口、OutputStream接口</h4><h5 id="FileInputStream类、FileOutStream类"><a href="#FileInputStream类、FileOutStream类" class="headerlink" title="FileInputStream类、FileOutStream类"></a>FileInputStream类、FileOutStream类</h5><p>读取文本和写入文本</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">File file = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(PATH)</span>;<br><span class="hljs-comment">// 1. 读取数据</span><br>...<br>FileInputStream FIS = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileInputStream(<span class="hljs-params">file</span>)</span>;<br><span class="hljs-comment">// 逐字节读取文件中的数据</span><br><span class="hljs-built_in">int</span> i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FIS</span>.</span></span>read<span class="hljs-literal">()</span>;<span class="hljs-comment">//转换成ASCII码</span><br><span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>i=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FIS</span>.</span></span>read<span class="hljs-literal">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 按字节数独取文件中的数据</span><br>Byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = <span class="hljs-keyword">new</span> Byte<span class="hljs-literal">[<span class="hljs-number">1024</span>]</span>;<br><span class="hljs-built_in">int</span> i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FIS</span>.</span></span>read(<span class="hljs-built_in">bytes</span>);<span class="hljs-comment">// 每次独取1KB，独取到的内容存放在bytes数据里，返回共读取的字节数</span><br><br><span class="hljs-comment">// 2. 写入数据</span><br>FileOutputStream FOS = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FOS(<span class="hljs-params">file</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FOS</span>.</span></span>write(<span class="hljs-built_in">bytes</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FOS</span>.</span></span>write(<span class="hljs-built_in">bytes</span>,<span class="hljs-literal">true</span>);<span class="hljs-comment">//true代表不覆盖写，而是在后边追加</span><br>...<br></code></pre></td></tr></table></figure><h4 id="字符流：Reader接口、Writer接口"><a href="#字符流：Reader接口、Writer接口" class="headerlink" title="字符流：Reader接口、Writer接口"></a>字符流：Reader接口、Writer接口</h4><h5 id="Reader接口-实现类"><a href="#Reader接口-实现类" class="headerlink" title="Reader接口 实现类"></a>Reader接口 实现类</h5><p><img src="https://i.loli.net/2020/11/12/pzCJ5WHZbwax1Bm.jpg" alt="Alt"></p><blockquote><p>BufferedReader<br>FileReader<br>InputStreamReader<br>…</p></blockquote><h6 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h6><p>InputStreamReader和FileInputStream很像，一个是按字节byte读取，一个是按照字符char读取</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">File file = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(PATH)</span>;<br><br>FileInputStream FIS = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileInputStream(<span class="hljs-params">file</span>)</span>;<br>InputStreamReader ISR = <span class="hljs-keyword">new</span> <span class="hljs-constructor">InputStreamReader(FIS,’<span class="hljs-params">gbk</span>’)</span>;<br><br><span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span><span class="hljs-literal">[<span class="hljs-number">64</span>]</span>;<br><span class="hljs-built_in">int</span> read = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ISR</span>.</span></span>read(c);<br></code></pre></td></tr></table></figure><h6 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h6><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">FileReader FR = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileReader(<span class="hljs-params">file</span>)</span>;<br><br><span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span><span class="hljs-literal">[<span class="hljs-number">64</span>]</span>;<br><br><span class="hljs-built_in">int</span> i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FR</span>.</span></span>read(c);<br><br></code></pre></td></tr></table></figure><h6 id="BufferReader类"><a href="#BufferReader类" class="headerlink" title="BufferReader类"></a>BufferReader类</h6><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs processing">FileInputStream FIS = <span class="hljs-keyword">new</span> FileInputStream(file);<br><br>InputStreamReader ISR = <span class="hljs-keyword">new</span> InputStreamReader(FIS);<br><br><span class="hljs-keyword">BufferedReader</span> BR = <span class="hljs-keyword">new</span> <span class="hljs-keyword">BufferedReader</span>(ISR);<br><br><span class="hljs-keyword">String</span> <span class="hljs-built_in">line</span> = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">//可以一行一行读取，不用破坏文本原来结构</span><br><span class="hljs-keyword">while</span>((<span class="hljs-built_in">line</span> = BR.readLine())!=<span class="hljs-keyword">null</span>)&#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">line</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Writer接口-实现类"><a href="#Writer接口-实现类" class="headerlink" title="Writer接口 实现类"></a>Writer接口 实现类</h5><p>与Reader接口差不多，对应理解即可</p><h4 id="IO流的关闭"><a href="#IO流的关闭" class="headerlink" title="IO流的关闭"></a>IO流的关闭</h4><p>JDK1.6之前需要手动关闭，之后Java可以自动关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">try(&#x2F;&#x2F;放各种需要关闭的可能出现异常的流<br>...<br>FileInputStream FIS &#x3D; new FileInputStream(file);<br>...<br>)<br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>推荐博客：<br>1、juejin.im/post/6844903910348603405<br>2、赵彦军的博客（CSDN）</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>numpy对数据集的基本操作：归一化、最值、均值、读取与保存</title>
    <link href="/2021/01/20/numpy%E5%AF%B9%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%9A%E5%BD%92%E4%B8%80%E5%8C%96%E3%80%81%E6%9C%80%E5%80%BC%E3%80%81%E5%9D%87%E5%80%BC%E3%80%81%E8%AF%BB%E5%8F%96%E4%B8%8E%E4%BF%9D%E5%AD%98/"/>
    <url>/2021/01/20/numpy%E5%AF%B9%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%9A%E5%BD%92%E4%B8%80%E5%8C%96%E3%80%81%E6%9C%80%E5%80%BC%E3%80%81%E5%9D%87%E5%80%BC%E3%80%81%E8%AF%BB%E5%8F%96%E4%B8%8E%E4%BF%9D%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="numpy对数据集的基本操作：归一化、最值、均值、读取与保存"><a href="#numpy对数据集的基本操作：归一化、最值、均值、读取与保存" class="headerlink" title="numpy对数据集的基本操作：归一化、最值、均值、读取与保存"></a>numpy对数据集的基本操作：归一化、最值、均值、读取与保存</h1><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><h2 id="一、-numpy对数据集的存取"><a href="#一、-numpy对数据集的存取" class="headerlink" title="一、 numpy对数据集的存取"></a>一、 numpy对数据集的存取</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta"># 当前工作目录</span><br><span class="hljs-symbol">pwd:</span> ~<br><br><span class="hljs-symbol">origin_dataset:</span> ~/example.csv<br></code></pre></td></tr></table></figure><p>最正宗的展示格式应该是txt，但csv格式文件只不过是用分隔符分开的数据组成的简单文本文件，因此这里用csv也无伤大雅。而且许多数据集也都是csv格式。</p><ol><li><strong>读取</strong>csv到变量：loadtxt()</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">np</span><span class="hljs-selector-class">.loadtxt</span>(<span class="hljs-selector-tag">filepath</span>, <span class="hljs-selector-tag">delimiter</span>, <span class="hljs-selector-tag">usecols</span>, <span class="hljs-selector-tag">unpack</span>, ...)<br></code></pre></td></tr></table></figure><ul><li><strong>filepath</strong>:加载文件路径</li><li><strong>delimiter</strong>:加载文件分隔符</li><li><strong>usecols</strong>:加载数据文件中列索引,<strong>人话</strong>：<em>指定加载数据中的第几列，默认全加载</em></li><li><strong>unpack</strong>:当加载多列数据时是否需要将数据列进行解耦赋值给不同的变量</li></ul><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">data_path = <span class="hljs-string">&quot;~/example.csv&quot;</span></span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">data = np.loadtxt(data_path, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>)</span><br><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">data</span><br>([...]<br>    [...]<br>    ...<br>    [...])<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>保存</strong>变量到文件：savetxt()</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">np</span>.savetxt(fileName, <span class="hljs-class"><span class="hljs-keyword">data</span>, ...)</span><br></code></pre></td></tr></table></figure><ul><li><strong>fileName</strong>:保存文件路径和名称</li><li><strong>data</strong>:需要保存的数据</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">data_path</span> = <span class="hljs-string">&quot;~/example.csv&quot;</span><br><span class="hljs-title">np</span>.savetxt(<span class="hljs-string">&quot;saveddata.csv&quot;</span>, <span class="hljs-class"><span class="hljs-keyword">data</span>)</span><br></code></pre></td></tr></table></figure><h2 id="二、numpy获取最值、均值"><a href="#二、numpy获取最值、均值" class="headerlink" title="二、numpy获取最值、均值"></a>二、numpy获取最值、均值</h2><p>测试数据</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">&gt;&gt;&gt; a=<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[2,5,7]</span>,<span class="hljs-comment">[6,3,6]</span>,<span class="hljs-comment">[7,3,2]</span>]</span><br>&gt;&gt;&gt; x=np.asanyarray(a)<br>&gt;&gt;&gt; x<br>array(<span class="hljs-comment">[<span class="hljs-comment">[1, 2, 3]</span>,</span><br><span class="hljs-comment">       <span class="hljs-comment">[2, 5, 7]</span>,</span><br><span class="hljs-comment">       <span class="hljs-comment">[6, 3, 6]</span>,</span><br><span class="hljs-comment">       <span class="hljs-comment">[7, 3, 2]</span>]</span>)<br></code></pre></td></tr></table></figure><p>numpy集成了获取数据最值、均值甚至更多操作的方法，这一点用起来和matlab很像</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">np.<span class="hljs-keyword">max</span>(<span class="hljs-built_in">data</span>, axis, <span class="hljs-params">...</span>)<br>np.<span class="hljs-keyword">min</span>(<span class="hljs-built_in">data</span>, axis, <span class="hljs-params">...</span>)<br>np.mean(<span class="hljs-built_in">data</span>, axis, <span class="hljs-params">...</span>)<br></code></pre></td></tr></table></figure><p>需要注意的是最常用的<code>axis</code>选项，对于2维数组（矩阵）而言：</p><ul><li><strong>axis = None</strong>: （默认）返回所有数据（行、列）中的最值/均值，返回一个数</li><li><strong>axis = 0</strong>: 返回所有列的最值/均值，相当于返回一个行向量（元素数与<strong>列数</strong>相同的array）</li><li><strong>axis = 1</strong>: 返回所有行的最值/均值，相当于返回一个列向量（元素数与<strong>行数</strong>相同的array）</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">max</span>(x)<br><span class="hljs-number">7</span><br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">max</span>(x,axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">array</span>([<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>])<br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">max</span>(x,axis=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">array</span>([<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>])<br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">min</span>(x)<br><span class="hljs-number">1</span><br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">min</span>(x,axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])<br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">min</span>(x,axis=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>])<br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">mean</span>(x)<br><span class="hljs-number">3.9166666666666665</span><br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">mean</span>(x,axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">array</span>([<span class="hljs-number">4</span>.  , <span class="hljs-number">3.25</span>, <span class="hljs-number">4.5</span> ])<br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">mean</span>(x,axis=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">array</span>([<span class="hljs-number">2</span>.        , <span class="hljs-number">4.66666667</span>, <span class="hljs-number">5</span>.        , <span class="hljs-number">4</span>.        ])<br></code></pre></td></tr></table></figure><h2 id="三、numpy对数据进行归一化"><a href="#三、numpy对数据进行归一化" class="headerlink" title="三、numpy对数据进行归一化"></a>三、numpy对数据进行归一化</h2><p>以下是笔者处理KDD99数据集时归一化的小demo，也是在此途中遇到的上述问题，记录下来，供自己以后参考。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;normlizing...&#x27;</span>)<br>kdd99_numeric = np.loadtxt(numeric_datasets, <span class="hljs-attribute">delimiter</span>=<span class="hljs-string">&#x27;,&#x27;</span>)<br>mean = np.mean(kdd99_numeric, <span class="hljs-attribute">axis</span>=0)<br>max = np.max(kdd99_numeric, <span class="hljs-attribute">axis</span>=0) + 1e-8<br>min = np.min(kdd99_numeric, <span class="hljs-attribute">axis</span>=0)<br>kdd99_numeric_norm = (kdd99_numeric - mean) / (max - min)<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;Done&#x27;</span>)<br><span class="hljs-builtin-name">print</span>(kdd99_numeric_norm)<br><br>np.savetxt(norm_numeric_datasets, kdd99_numeric_norm, <span class="hljs-attribute">delimiter</span>=<span class="hljs-string">&#x27;,&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上述使用的是所谓 <strong>min-max标准化（Min-Max Normalization）（线性函数归一化）</strong> 方法，除此之外，在笔者还了解到还存在 <strong>Z-score标准化方法</strong> ，关于此信息可以查阅参考资料[2]。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]. <a href="https://blog.csdn.net/MESSI_JAMES/article/details/80487389">Numpy读取csv文件</a><br>[2]. <a href="https://blog.csdn.net/program_developer/article/details/78637711">机器学习-数据归一化方法（Normalization Method）</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python日积月累</title>
    <link href="/2021/01/19/Python%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    <url>/2021/01/19/Python%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="python-判断元素是否包含于list"><a href="#python-判断元素是否包含于list" class="headerlink" title="python 判断元素是否包含于list"></a>python 判断元素是否包含于list</h1><p>这里涉及到list的查找方法，参考<a href="https://blog.csdn.net/lachesis999/article/details/53185299">python中list的四种查找方法</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2</span> <span class="hljs-keyword">in</span> a<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">9</span> <span class="hljs-keyword">in</span> a<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> a<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">9</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> a<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="Python-拟合正态分布"><a href="#Python-拟合正态分布" class="headerlink" title="Python 拟合正态分布"></a>Python 拟合正态分布</h1><p><strong>待解决的问题</strong>：对一个一维的数串拟合到正态分布。<br>所谓拟合正态分布，实质上算出均值 $ \mu $ 和方差 $ \sigma^2 $ 即可确定分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>X = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">34</span>,<span class="hljs-number">3</span>,<span class="hljs-number">23</span>,<span class="hljs-number">56</span>,<span class="hljs-number">7</span>,<span class="hljs-number">87</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">34</span>,<span class="hljs-number">5678</span>,<span class="hljs-number">7</span>,<span class="hljs-number">654</span>,<span class="hljs-number">3</span>,<span class="hljs-number">45</span>,<span class="hljs-number">67</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>mu = np.mean(X)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sigma = np.std(X)<br><span class="hljs-meta">&gt;&gt;&gt; </span>mu,sigma**<span class="hljs-number">2</span><br>(<span class="hljs-number">320.3809523809524</span>, <span class="hljs-number">1453914.5215419505</span>)<br></code></pre></td></tr></table></figure><h1 id="Python-中三元表达式的实现"><a href="#Python-中三元表达式的实现" class="headerlink" title="Python 中三元表达式的实现"></a>Python 中三元表达式的实现</h1><p>C语言等其它高级语言中，都有<code>?:</code>这样的三元表达式替换复杂的<code>if else</code>。</p><p>在<code>python</code>中，本身没有三元表达式，但可以利用下面的简单语句实现相似功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python">A <span class="hljs-keyword">if</span> a&gt;b <span class="hljs-keyword">else</span> B<br><span class="hljs-comment"># 等价于</span><br><span class="hljs-keyword">if</span> a&gt;b:<br>    <span class="hljs-keyword">return</span> A<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> B<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python">(B ,A )[a&gt;b] <span class="hljs-comment"># (假则, 真则)[判断]</span><br><span class="hljs-comment"># 等价于</span><br><span class="hljs-keyword">if</span> a&gt;b:<br>    <span class="hljs-keyword">return</span> A<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> B<br></code></pre></td></tr></table></figure><p>但第二种方法比较不受程序员们的待见，实质上是利用了将<code>False</code>等同于<code>0</code>，将<code>True</code>等同于<code>1</code>，然后对前边的<code>tuple</code>进行索引。</p><p><strong>参考</strong><br>[1]. <a href="https://blog.csdn.net/Sinchb/article/details/8081754">python 中 ? : 三元表达式 的实现方式</a><br>[1]. <a href="https://eastlakeside.gitbook.io/interpy-zh/ternary_operators">三元运算符- Python进阶</a><br>[3]. <a href="https://www.cnblogs.com/mywood/p/7416893.html">python中的三元表达式（三目运算符）</a></p><h1 id="进度条工具TQDM"><a href="#进度条工具TQDM" class="headerlink" title="进度条工具TQDM"></a>进度条工具TQDM</h1><p><a href="https://github.com/tqdm/tqdm">GitHub项目地址</a><br><a href="https://tqdm.github.io/">文档地址</a></p><p>看上去很酷炫的进度条工具，可以可视化<strong>time consuming</strong>的程序等待过程。</p><p>使用方法在<code>PySAD</code>的<a href="https://pysad.readthedocs.io/en/latest/examples.html#example-full-usage">Example</a>中有体现。</p><p><img src="https://gitee.com/songz7026/image-pool/raw/master/Python/tqdm%E6%BC%94%E7%A4%BA.gif" alt="项目仓库中的示例"></p><h1 id="Python删除变量"><a href="#Python删除变量" class="headerlink" title="Python删除变量"></a>Python删除变量</h1><p>在Python中删除指定变量以节省空间，使用<code>del var</code>命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>a=<span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> a<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;input&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>NameError: name <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br><br></code></pre></td></tr></table></figure><h1 id="关于Python中Iterator重置问题"><a href="#关于Python中Iterator重置问题" class="headerlink" title="关于Python中Iterator重置问题"></a>关于Python中Iterator重置问题</h1><p>Iterator是Python中常见的类型，不特指具体类型。</p><p>一般此类只提供<strong>next</strong>()方法获得迭代器中下一个元素。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>a=np.random.random((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>b=<span class="hljs-built_in">iter</span>(a)    <br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>array([[<span class="hljs-number">0.73612967</span>, <span class="hljs-number">0.01244284</span>, <span class="hljs-number">0.21440946</span>, <span class="hljs-number">0.29223116</span>],<br>       [<span class="hljs-number">0.39542505</span>, <span class="hljs-number">0.14566755</span>, <span class="hljs-number">0.21281517</span>, <span class="hljs-number">0.04957406</span>],<br>       [<span class="hljs-number">0.90193673</span>, <span class="hljs-number">0.1955091</span> , <span class="hljs-number">0.64111833</span>, <span class="hljs-number">0.78027169</span>]])<br><span class="hljs-meta">&gt;&gt;&gt; </span>b.__next__()<br>array([<span class="hljs-number">0.73612967</span>, <span class="hljs-number">0.01244284</span>, <span class="hljs-number">0.21440946</span>, <span class="hljs-number">0.29223116</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>b.__next__()<br>array([<span class="hljs-number">0.39542505</span>, <span class="hljs-number">0.14566755</span>, <span class="hljs-number">0.21281517</span>, <span class="hljs-number">0.04957406</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>b.__iter__()<br>&lt;iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000001BFA787FF08</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>问题</strong>：有的时候需要<strong>重新进行迭代</strong>，即对迭代器的指针重置到初始位置。</p><p>但是迭代器一般只有<code>iter()</code>和<code>next()</code>方法，没有重置的方法，非常的令人头疼。</p><p>经过调查，有关于<strong>tee</strong>的方法，但是存在质疑，因为它主要不是干这个的。所以目前笔者能够想到的方法是：<strong>重新定义一个新的迭代器</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>a=np.random.random((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>b=<span class="hljs-built_in">iter</span>(a)    <br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>array([[<span class="hljs-number">0.73612967</span>, <span class="hljs-number">0.01244284</span>, <span class="hljs-number">0.21440946</span>, <span class="hljs-number">0.29223116</span>],<br>       [<span class="hljs-number">0.39542505</span>, <span class="hljs-number">0.14566755</span>, <span class="hljs-number">0.21281517</span>, <span class="hljs-number">0.04957406</span>],<br>       [<span class="hljs-number">0.90193673</span>, <span class="hljs-number">0.1955091</span> , <span class="hljs-number">0.64111833</span>, <span class="hljs-number">0.78027169</span>]])<br><span class="hljs-meta">&gt;&gt;&gt; </span>b.__next__()<br>array([<span class="hljs-number">0.73612967</span>, <span class="hljs-number">0.01244284</span>, <span class="hljs-number">0.21440946</span>, <span class="hljs-number">0.29223116</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>b.__next__()<br>array([<span class="hljs-number">0.39542505</span>, <span class="hljs-number">0.14566755</span>, <span class="hljs-number">0.21281517</span>, <span class="hljs-number">0.04957406</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>b.__iter__()<br>&lt;iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000001BFA787FF08</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>b.__next__()<br>array([<span class="hljs-number">0.90193673</span>, <span class="hljs-number">0.1955091</span> , <span class="hljs-number">0.64111833</span>, <span class="hljs-number">0.78027169</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>b.__next__()<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;input&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>StopIteration<br><span class="hljs-meta">&gt;&gt;&gt; </span>c=<span class="hljs-built_in">iter</span>(a)<br><span class="hljs-meta">&gt;&gt;&gt; </span>c.__next__()<br>array([<span class="hljs-number">0.73612967</span>, <span class="hljs-number">0.01244284</span>, <span class="hljs-number">0.21440946</span>, <span class="hljs-number">0.29223116</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>c.__next__()<br>array([<span class="hljs-number">0.39542505</span>, <span class="hljs-number">0.14566755</span>, <span class="hljs-number">0.21281517</span>, <span class="hljs-number">0.04957406</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>c.__next__()<br>array([<span class="hljs-number">0.90193673</span>, <span class="hljs-number">0.1955091</span> , <span class="hljs-number">0.64111833</span>, <span class="hljs-number">0.78027169</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>c.__next__()<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;input&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>StopIteration<br></code></pre></td></tr></table></figure><p>新的小tip：可以删除原来的迭代器，重新定义重名变量，节省空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> b<br><span class="hljs-meta">&gt;&gt;&gt; </span>b.__next__()<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;input&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>NameError: name <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br><span class="hljs-meta">&gt;&gt;&gt; </span>b=<span class="hljs-built_in">iter</span>(a)<br><span class="hljs-meta">&gt;&gt;&gt; </span>b.__next__()<br>array([<span class="hljs-number">0.73612967</span>, <span class="hljs-number">0.01244284</span>, <span class="hljs-number">0.21440946</span>, <span class="hljs-number">0.29223116</span>])<br></code></pre></td></tr></table></figure><h1 id="使用pandas查找数组中元素出现的次数"><a href="#使用pandas查找数组中元素出现的次数" class="headerlink" title="使用pandas查找数组中元素出现的次数"></a>使用pandas查找数组中元素出现的次数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-meta">&gt;&gt;&gt; </span>a=np.random.random((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>pd.value_counts(a)<br><span class="hljs-comment"># 元素 出现次数 </span><br><span class="hljs-number">2</span>    <span class="hljs-number">2</span><br><span class="hljs-number">4</span>    <span class="hljs-number">2</span><br><span class="hljs-number">1</span>    <span class="hljs-number">1</span><br><span class="hljs-number">3</span>    <span class="hljs-number">1</span><br>dtype: int64<br><span class="hljs-meta">&gt;&gt;&gt; </span>np.array(pd.value_counts(a))<br>array([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], dtype=int64)<br></code></pre></td></tr></table></figure><h1 id="List的中是否包含某元素"><a href="#List的中是否包含某元素" class="headerlink" title="List的中是否包含某元素"></a>List的中是否包含某元素</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.__contains__(<span class="hljs-number">2</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a.__contains__(<span class="hljs-number">6</span>)<br><span class="hljs-literal">False</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>日积月累</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python的符号分隔值格式(xsv)文件读取</title>
    <link href="/2021/01/18/Python%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%88%86%E9%9A%94%E5%80%BC%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <url>/2021/01/18/Python%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%88%86%E9%9A%94%E5%80%BC%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Python的符号分隔值格式-xsv-文件读取"><a href="#Python的符号分隔值格式-xsv-文件读取" class="headerlink" title="Python的符号分隔值格式(xsv)文件读取"></a>Python的符号分隔值格式(xsv)文件读取</h1><h2 id="一、xsv文件介绍"><a href="#一、xsv文件介绍" class="headerlink" title="一、xsv文件介绍"></a>一、xsv文件介绍</h2><p>xsv(x-separated values)x分隔值文件格式，最常见的是</p><blockquote><p>csv(Comma-Separated Values, 逗号分隔值)<br>tsv(Tab-separated values, 制表符分隔值)<br><font size=2, color='gray'> xsv 名称是笔者杜撰，不确定是否真的有这个叫法，也不确定除了上述两种格式是否还有其它格式，即其它分隔方式。这样做的目的是将此类文件统称起来。 </font></p></blockquote><p>一定意义上来说，这类文件格式的区别其实就是分隔符不同，在python中体现为<code>delimiter</code>等参数不同。</p><p>此类文件用简单的<strong>文件编辑器</strong>即可打开，如 <em>Windows系统自带的记事本(nptepad)、关爱孤儿的vim编辑器</em> 以及 <em>VSCode</em> 等。不过一般此类文件用于存储大批量有规则的数据，主要使用<code>code</code>进行批量自动化读取和更多操作。</p><p>以下是来自wikipida的解释：</p><h3 id="1、csv格式"><a href="#1、csv格式" class="headerlink" title="1、csv格式"></a>1、csv格式</h3><p>制表符分隔值 （Tab-separated values，TSV）格式文件是一种用于储存数据的文本格式文件，其数据以表格结构（例如 数据库 或 电子表格 数据）储存。每一行储存一条记录。 每条记录的各个字段间以制表符作为分隔。</p><p>TSV 格式是一种被广泛支持的文件格式，它经常用来在不同的计算机程序之间传递数据，支持格式。 例如，TSV文件可以用来在数据库和电子表格之间传递数据。</p><p>TSV 格式是逗号分隔值（CSV）格式的一种变体，CSV 格式以逗号作为字段间的分隔符号，因为逗号本身是一种很常见的文本数据，因此常常会引起一些问题，而制表符在文本数据中相对少见。在 IANA 标准中，数据字段内禁止使用制表符。</p><h3 id="2、tsv格式"><a href="#2、tsv格式" class="headerlink" title="2、tsv格式"></a>2、tsv格式</h3><p>逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。通常，所有记录都有完全相同的字段序列。</p><p>CSV文件格式的通用标准并不存在，但是在RFC 4180中有基础性的描述。使用的字符编码同样没有被指定，但是7-bit ASCII是最基本的通用编码。</p><ul><li>由于笔者是通过关注到tshark解析pcap文件的代码了解到tsv文件的，因此以下记录了解析得到的tsv文件的文件头部（位于tsv文件的第一行，指示了后序每行数据每列代表的内容）</li></ul><p><img src="https://gitee.com/songz7026/image-pool/raw/master/Python/xsv_tsv_header.jpg" alt="pcap解析得到的tsv文件的文件头"></p><h2 id="二、Python-I-O-简介（文件读取）"><a href="#二、Python-I-O-简介（文件读取）" class="headerlink" title="二、Python I/O 简介（文件读取）"></a>二、Python I/O 简介（文件读取）</h2><p>涉及到对xsv文件的操作，需要了解Python文件读取的主要方法。</p><h3 id="1、open-filename-mode-…"><a href="#1、open-filename-mode-…" class="headerlink" title="1、open(filename, mode, …)"></a>1、open(filename, mode, …)</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">open</span>(filename, <span class="hljs-keyword">mode</span>, ...)<br>(<span class="hljs-symbol">&lt;PATH&gt;</span>, <span class="hljs-string">&quot;rwxts...&quot;</span>, ...)//<span class="hljs-keyword">mode</span>可以参看builtins.<span class="hljs-keyword">py</span>源代码中的注释<br></code></pre></td></tr></table></figure><ul><li><code>return</code>: 方法返回一个<code>file</code>对象，该对象可以进行进一步操作。</li><li><code>filename</code>: 操作的的文件路径</li><li><code>mode</code>: 文件操作模式选项，可以进一步细分为<code>rwx...</code><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">========= ===============================================================<br>Character Meaning 来自builtins.<span class="hljs-keyword">py</span>中<span class="hljs-keyword">open</span>()方法下的注释<br>--------- ---------------------------------------------------------------<br>文件打开模式，特别注意光标的位置（光标向后的位置会被覆盖）<br><span class="hljs-string">&#x27;r&#x27;</span>       <span class="hljs-keyword">open</span> <span class="hljs-keyword">for</span> reading (default) 只读(默认) 光标位于开头<br><span class="hljs-string">&#x27;w&#x27;</span>       <span class="hljs-keyword">open</span> <span class="hljs-keyword">for</span> writing, truncating the <span class="hljs-keyword">file</span> <span class="hljs-keyword">first</span> 只写 光标位于开头 原有内容删除 若文件不存在则新建文件<br><span class="hljs-string">&#x27;x&#x27;</span>       create <span class="hljs-keyword">a</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">file</span> <span class="hljs-built_in">and</span> <span class="hljs-keyword">open</span> it <span class="hljs-keyword">for</span> writing 只写 新建文件 如果该文件已存在则会报错<br><span class="hljs-string">&#x27;a&#x27;</span>       <span class="hljs-keyword">open</span> <span class="hljs-keyword">for</span> writing, appending <span class="hljs-keyword">to</span> the end of the <span class="hljs-keyword">file</span> <span class="hljs-keyword">if</span> it <span class="hljs-built_in">exists</span> 只写（追加<span class="hljs-keyword">append</span>） 光标位于最后 若文件不存在则新建文件<br><br>返回文件的形式<br><span class="hljs-string">&#x27;b&#x27;</span>       binary <span class="hljs-keyword">mode</span> 返回binary文件， 对于<span class="hljs-string">&#x27;byte&#x27;</span>组成的文件<br><span class="hljs-string">&#x27;t&#x27;</span>       text <span class="hljs-keyword">mode</span> (default) 返回文本文件， 对于<span class="hljs-string">&quot;str&quot;</span>组成的文件 <br>覆盖<br><span class="hljs-string">&#x27;+&#x27;</span>       <span class="hljs-keyword">open</span> <span class="hljs-keyword">a</span> disk <span class="hljs-keyword">file</span> <span class="hljs-keyword">for</span> updating (reading <span class="hljs-built_in">and</span> writing) 打开一个文件进行更新(可读可写)<br><br>其它<br><span class="hljs-string">&#x27;U&#x27;</span>       universal newline <span class="hljs-keyword">mode</span> (deprecated) 通用换行模式<br>========= ===============================================================<br></code></pre></td></tr></table></figure>关于open()方法更详细的操作可以参考</li></ul><ol><li>源代码( <em>在编辑器中查找open()的定义位置</em> )中的注释，</li><li><a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files">官方文档</a></li><li><a href="https://www.runoob.com/python/python-func-open.html">菜鸟教程：Python open() 函数</a></li></ol><h4 id="file对象方法"><a href="#file对象方法" class="headerlink" title="file对象方法"></a><code>file</code>对象方法</h4><ul><li><code>file.read([size])</code>：size 未指定则返回整个文件，如果文件大小 &gt;2 倍内存则有问题，f.read()读到文件尾时返回””(空字串)。</li><li><code>file.readline()</code>：返回一行。</li><li><code>file.readlines([size])</code>：返回包含size行的列表, size 未指定则返回全部行。</li><li><code>for line in f: print line</code> ：通过迭代器访问。</li><li><code>f.write(&quot;hello\n&quot;)</code>：如果要写入字符串以外的数据,先将他转换为字符串。</li><li><code>f.tell()</code>：返回一个整数,表示当前文件指针的位置(就是到文件头的字节数)。</li><li><code>f.seek(偏移量,[起始位置])</code>：用来移动文件指针。<br>偏移量: 单位为字节，可正可负<br>起始位置: <strong>0</strong> - 文件头, 默认值; <strong>1</strong> - 当前位置; <strong>2</strong> - 文件尾</li><li><code>f.close()</code>： 关闭文件</li></ul><h3 id="2、with关键字"><a href="#2、with关键字" class="headerlink" title="2、with关键字"></a>2、with关键字</h3><blockquote><p>引子：使用内置open()打开文件之后，要close()以正确关闭以释放资源</p></blockquote><p><code>open()</code>操作常常与<code>with</code>关键字连用，解决引子中麻烦的累赘问题</p><ul><li>对比之后，显而易见</li></ul><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">try</span></span> <span class="hljs-function"><span class="hljs-title">open</span>():</span><br><span class="hljs-function">...</span><br><span class="hljs-function"><span class="hljs-variable"><span class="hljs-keyword">finally</span></span>:</span><br><span class="hljs-function"><span class="hljs-title">close</span>()</span><br></code></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">with</span> <span class="hljs-keyword">open</span>()<br>...<span class="hljs-comment">//更加简洁，自动关闭</span><br></code></pre></td></tr></table></figure><h2 id="三、Python对xsv的支持"><a href="#三、Python对xsv的支持" class="headerlink" title="三、Python对xsv的支持"></a>三、Python对xsv的支持</h2><p>在Python中，有对csv的支持，其它变体（包括tsv）一律视为其中的<code>delimiter</code>等参数不同。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> csv<br></code></pre></td></tr></table></figure><p><a href="https://docs.python.org/3/library/csv.html">Python csv Document</a></p><p><a href="https://docs.python.org/zh-cn/3/library/csv.html">Python csv 官方文档</a></p><h3 id="1、csv文件的读取"><a href="#1、csv文件的读取" class="headerlink" title="1、csv文件的读取"></a>1、csv文件的读取</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">csv.reader(csvfile, <span class="hljs-attribute">dialect</span>=<span class="hljs-string">&#x27;excel&#x27;</span>, *<span class="hljs-number">*f</span>mtparams)<br></code></pre></td></tr></table></figure><ul><li><code>return</code>: <code>reader</code>对象</li><li><code>csvfile</code>: 文件路径</li><li><code>dialect</code>: 指明读取的对象是何种csv文件的变体，如tsv。</li><li><code>**fmtparams</code>：<strong>变种与格式参数</strong> 覆盖当前变种(dialect)的单个格式设置</li></ul><blockquote><p>Python认定csv格式的各种变种都是通过改了一堆参数得到的，（参见python文档），如</p><blockquote><p>dialect.delimiler 用于分隔字段的单字符，默认为逗号”,”<br>dialect.doublequole …<br>dialect.escapechar …<br>..</p></blockquote></blockquote><h3 id="2、iterator迭代器"><a href="#2、iterator迭代器" class="headerlink" title="2、iterator迭代器"></a>2、iterator迭代器</h3><p>引子：csv.reader()使用的对象只需要下列两点，即可顺利打开</p><blockquote><ol><li>满足iterator协议</li><li>并且每次都调用<code>__next__()</code>方法都返回<code>str</code> </li></ol><p>关键字：iterator协议；__next()__</p></blockquote><p><strong>迭代器对象</strong>：表示一串数据的对象，如<code>csv.reader()</code>返回的<code>reader</code>对象。配合使用<code>__next__()</code>方法即可逐行获得字符串。</p><p><img src="https://gitee.com/songz7026/image-pool/raw/master/Python/xsv_iterator.png" alt="iterator对象示意图"></p><ul><li><code>__next__()</code>：返回迭代器对象中的下一项，到达最后一项溢出会引发<code>StopIteration</code>异常</li></ul><h3 id="3、csv-reader-和csv-writerow"><a href="#3、csv-reader-和csv-writerow" class="headerlink" title="3、csv.reader()和csv.writerow()"></a>3、csv.reader()和csv.writerow()</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span> datasets1 = <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-comment"># 设置文件路径</span><br><span class="hljs-meta">&gt;&gt;</span> obj_file1 = open(datasets1) <span class="hljs-comment"># 获得file类型文件obj_file</span><br><span class="hljs-meta">&gt;&gt;</span> obj_reader = csv.reader(obj_file1) <span class="hljs-comment"># 获得reader类型文件；reader(csvfile)接受csvfile类型作为参数，file类型被向下转换到csvfile类型</span><br><br><span class="hljs-meta">&gt;&gt;</span> datasets2 = <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-comment"># 设置文件路径</span><br><span class="hljs-meta">&gt;&gt;</span> obj_file2 = open(datasets2,<span class="hljs-string">&#x27;w&#x27;</span>) <br><span class="hljs-meta">&gt;&gt;</span> obj_file2.writerow([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">33</span>])<br><span class="hljs-meta">&gt;&gt;</span> obj_file2.writerow([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>])<br><span class="hljs-meta">&gt;&gt;</span> obj_file2.writerow([<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>经过测试，发现再writerow()后还插入了一个空行，导致插入多行时会产生大量冗余的空行。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 生成的文件</span><br><span class="hljs-attribute">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">33</span><br><br><span class="hljs-attribute">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">5</span><br><br><span class="hljs-attribute">6</span>，<span class="hljs-number">4</span>，<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>查看文档发现是由于没有在<code>open()</code>阶段设置换行符参数<code>newline</code>，因为不同的系统有不同的换行符，如<code>Windows</code>采用<code>CRLF</code>(回车换行’\r\n’)，<code>Linux</code>采用<code>LF</code>(换行’\n’)。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span> datasets = <span class="hljs-string">&#x27;...&#x27;</span><br><span class="hljs-meta">&gt;&gt;</span> obj_file = open(dataset,<span class="hljs-string">&#x27;w&#x27;</span>,newline=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;</span> obj_file2.writerow([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">33</span>])<br><span class="hljs-meta">&gt;&gt;</span> obj_file2.writerow([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>])<br><span class="hljs-meta">&gt;&gt;</span> obj_file2.writerow([<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 生成的文件</span><br><span class="hljs-attribute">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">33</span><br><span class="hljs-attribute">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">5</span><br><span class="hljs-attribute">6</span>，<span class="hljs-number">4</span>，<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="4、遍历csv"><a href="#4、遍历csv" class="headerlink" title="4、遍历csv"></a>4、遍历csv</h3><p>笔者利用迭代器的<strong>next</strong>()方法在最后一行之后继续调用会产生<code>StopIteration</code>异常这一特性，想出了如下代码以遍历整个csv文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">try</span>:<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>datasets = <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-comment"># 设置文件路径</span><br>obj_file = <span class="hljs-built_in">open</span>(datasets) <span class="hljs-comment"># 获得file类型文件obj_file</span><br>obj_reader = csv.reader(obj_file) <span class="hljs-comment"># 获得reader类型文件；reader(csvfile)接受csvfile类型作为参数，file类型被向下转换到csvfile类型</span><br><br>row = obj_reader.__next__()<br><span class="hljs-keyword">except</span> StopIteration:<br><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h3 id="5、其它"><a href="#5、其它" class="headerlink" title="5、其它"></a>5、其它</h3><p>笔者在测试过程中，发现单纯使用<code>open()</code>得到的<code>file</code>类型也有迭代器方法<code>__next__()</code>，因此将二者做了对比如下。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span> datasets = <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-comment"># 设置文件路径</span><br><span class="hljs-meta">&gt;&gt;</span> obj_file = open(datasets) <span class="hljs-comment"># 获得file类型文件obj_file</span><br><span class="hljs-meta">&gt;&gt;</span> obj_reader = csv.reader(obj_file) <span class="hljs-comment"># 获得reader类型文件；reader(csvfile)接受csvfile类型作为参数，file类型被向下转换到csvfile类型</span><br><br><span class="hljs-meta">&gt;&gt;</span> obj_file.__next__()<br><span class="hljs-string">&#x27;0,tcp,http,SF,181,5450,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,8,8,0.00,0.00,0.00,0.00,1.00,0.00,0.00,9,9,1.00,0.00,0.11,0.00,0.00,0.00,0.00,0.00,normal.\n&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;</span> obj_reader.__next__()<br>[<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;tcp&#x27;</span>, <span class="hljs-string">&#x27;http&#x27;</span>, <span class="hljs-string">&#x27;SF&#x27;</span>, <span class="hljs-string">&#x27;239&#x27;</span>, <span class="hljs-string">&#x27;486&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;1.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;19&#x27;</span>, <span class="hljs-string">&#x27;19&#x27;</span>, <span class="hljs-string">&#x27;1.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.05&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;normal.&#x27;</span>]<br><br><span class="hljs-meta">&gt;&gt;</span> obj_file.__next__()<br><span class="hljs-string">&#x27;0,tcp,http,SF,235,1337,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,8,8,0.00,0.00,0.00,0.00,1.00,0.00,0.00,29,29,1.00,0.00,0.03,0.00,0.00,0.00,0.00,0.00,normal.\n&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;</span> obj_reader.__next__()<br>[<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;tcp&#x27;</span>, <span class="hljs-string">&#x27;http&#x27;</span>, <span class="hljs-string">&#x27;SF&#x27;</span>, <span class="hljs-string">&#x27;219&#x27;</span>, <span class="hljs-string">&#x27;1337&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;1.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;39&#x27;</span>, <span class="hljs-string">&#x27;39&#x27;</span>, <span class="hljs-string">&#x27;1.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.03&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;normal.&#x27;</span>]<br><br><span class="hljs-meta">&gt;&gt;</span> type(obj_file.__next__())<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span><br><br><span class="hljs-meta">&gt;&gt;</span> type(obj_reader.__next__())<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">list</span>&#x27;&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dns"># 实验使用的KDD99_10_percent 最初的几行<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">181,5450,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,8</span>,<span class="hljs-number">8,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,9</span>,<span class="hljs-number">9,1.00,0</span>.<span class="hljs-number">00,0.11,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">239,486,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,8</span>,<span class="hljs-number">8,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,19</span>,<span class="hljs-number">19,1.00,0</span>.<span class="hljs-number">00,0.05,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">235,1337,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,8</span>,<span class="hljs-number">8,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,29</span>,<span class="hljs-number">29,1.00,0</span>.<span class="hljs-number">00,0.03,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">219,1337,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,6</span>,<span class="hljs-number">6,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,39</span>,<span class="hljs-number">39,1.00,0</span>.<span class="hljs-number">00,0.03,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">217,2032,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,6</span>,<span class="hljs-number">6,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,49</span>,<span class="hljs-number">49,1.00,0</span>.<span class="hljs-number">00,0.02,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">217,2032,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,6</span>,<span class="hljs-number">6,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,59</span>,<span class="hljs-number">59,1.00,0</span>.<span class="hljs-number">00,0.02,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">212,1940,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">2,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,1.00,1</span>,<span class="hljs-number">69,1.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">04,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">159,4087,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,5</span>,<span class="hljs-number">5,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,11</span>,<span class="hljs-number">79,1.00,0</span>.<span class="hljs-number">00,0.09,0</span>.<span class="hljs-number">04,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">210,151,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,8,8</span>,<span class="hljs-number">0.00,0.00</span>,<span class="hljs-number">0.00,0.00</span>,<span class="hljs-number">1.00,0.00</span>,<span class="hljs-number">0.00,8,89</span>,<span class="hljs-number">1.00,0.00</span>,<span class="hljs-number">0.12,0.04</span>,<span class="hljs-number">0.00,0.00</span>,<span class="hljs-number">0.00,0.00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">212,786,0</span>,<span class="hljs-number">0,0,1,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,8</span>,<span class="hljs-number">8,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,8</span>,<span class="hljs-number">99,1.00,0</span>.<span class="hljs-number">00,0.12,0</span>.<span class="hljs-number">05,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br>...<br></code></pre></td></tr></table></figure><p>通过对比可以发现，数据集获得的<code>file</code>对象和<code>reader</code>对象关于迭代方法的异同有</p><ol><li><p>共同点：均可迭代</p></li><li><p>共同点：实验中两个有关联的对象的迭代指针是<strong>共享</strong>的。</p></li><li><p>不同点：返回的类型不同。分别是<code>str</code>和<code>list</code></p></li></ol><p>进一步了解这涉及到了Python中重要的<strong>迭代器</strong>和<strong>生成器</strong>，Python中很多数据类型都可以作为迭代器，关于更详细的迭代器的内容与本文不大，不做赘述。</p><h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><p>[1]. <a href="https://zh.wikipedia.org/wiki/%E5%88%B6%E8%A1%A8%E7%AC%A6%E5%88%86%E9%9A%94%E5%80%BC">wikipida: 制表符分隔值</a><br>[2]. <a href="https://zh.wikipedia.org/wiki/%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94%E5%80%BC">wikipida: 逗号分隔值</a><br>[3]. <a href="https://www.runoob.com/python/python-func-open.html">菜鸟教程：Python open() 函数</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>文件读取(File I/O)</tag>
      
      <tag>迭代器</tag>
      
      <tag>csv文件</tag>
      
      <tag>with()</tag>
      
      <tag>open()</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KDD99数据集的特征(Features)介绍</title>
    <link href="/2021/01/17/KDD99%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%89%B9%E5%BE%81(Features)%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/01/17/KDD99%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%89%B9%E5%BE%81(Features)%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="KDD99数据集的特征-Features-介绍"><a href="#KDD99数据集的特征-Features-介绍" class="headerlink" title="KDD99数据集的特征(Features)介绍"></a>KDD99数据集的特征(Features)介绍</h1><p>KDD99是一个用来从正常连接中监测非正常连接的数据集。产出于1999年Thrid International Knowlegde Discovery and Data Mining Tools Competition，其目的是建立一个稳定的的入侵检测系统。</p><p>KDD99包含了置入攻击的军事网络环境中的记录。攻击可以分类为：</p><ul><li><strong>DoS攻击</strong>：Denial of Service</li><li><strong>R2U</strong>：Remote to User</li><li><strong>U2R</strong>：User to Root</li><li><strong>探针攻击</strong>：Probing</li></ul><p>四类攻击在数据集中的详细类型为：</p><table><thead><tr><th>攻击类别</th><th>具体攻击</th><th>测试集中的额外具体攻击</th></tr></thead><tbody><tr><td>Dos</td><td>back, neptune, smurf, teardrop, land, pod</td><td>apache2, mailbomb, processtable</td></tr><tr><td>Probe</td><td>satan, portsweep, ipsweep, nmap</td><td>mscan, saint</td></tr><tr><td>R2L</td><td>warezmaster, warezclient, ftpwrite, gusspassword, imap, multihop, phf, spy</td><td>sendmail,named, snmpgetattack, snmpguess, xlock,xsnoop, worm</td></tr><tr><td>U2R</td><td>rootkit, bufferoverflow, loadmodule, perl</td><td>httptunnel, ps, sqlattack,xterm</td></tr></tbody></table><p>KDD99数据集是 <em>DARPA数据集</em> 的 <strong>特征提取(Feature Extract)</strong> 版本（ <em>DARPA</em> 是原始数据集）KDD99对每个连接提取了 <strong>41</strong> 个特征，使用<strong>Bro-IDS</strong>工具对数据贴标签。</p><p>其41个特征可以按以下方式分类：</p><ul><li>1-9    TCP连接的基本特征</li><li>10-22    TCP连接的内容特征</li><li>23-31    基于时间的网络流量统计特征，使用2秒的时间窗(Traffic features computed using a two-second time window)</li><li>32-41    基于主机的网络流量统计特征，主机特征(Host features)，用来评估持续时间在两秒钟以上的攻击</li></ul><h2 id="TCP连接的基本特征"><a href="#TCP连接的基本特征" class="headerlink" title="TCP连接的基本特征"></a>TCP连接的基本特征</h2><table><thead><tr><th align="center">feature name</th><th>description</th><th align="center">type</th></tr></thead><tbody><tr><td align="center">duration</td><td>length (number of seconds) of the connection<br>连接的持续时间，以秒(s)为单位<br><strong>[0 ~ 58329]</strong><br>它的定义是从TCP连接以3次握手建立算起，到FIN/ACK连接结束为止的时间；若为UDP协议类型，则将每个UDP数据包作为一条连接。(数据集中出现大量的duration=0 的情况，是因为该条连接的持续时间不足1秒.)</td><td align="center">continuous<br>连续</td></tr><tr><td align="center">protocol_type</td><td>type of the protocol, e.g. tcp, udp, etc.<br>协议类型，此数据集中有三种：<br><strong>TCP, UDP, ICMP</strong></td><td align="center">discrete<br>离散</td></tr><tr><td align="center">service</td><td>network service on the destination, e.g., http, telnet, etc.<br>连接目的端的网络服务。有70+种：<br><strong>aol, auth, bgp, courier, csnet_ns, ctf, daytime, discard, domain, domain_u, echo, eco_i, ecr_i, efs, exec, finger, ftp, ftp_data, gopher, harvest, hostnames, http, http_2784, http_443, http_8001, imap4, IRC, iso_tsap, klogin, kshell, ldap, link, login, mtp, name, netbios_dgm, netbios_ns, netbios_ssn, netstat, nnsp, nntp, ntp_u, other, pm_dump, pop_2, pop_3, printer, private, red_i, remote_job, rje, shell, smtp, sql_net, ssh, sunrpc, supdup, systat, telnet, tftp_u, tim_i, time, urh_i, urp_i, uucp, uucp_path, vmnet, whois, X11, Z39_50</strong></td><td align="center">discrete<br>离散</td></tr><tr><td align="center">src_bytes</td><td>number of data bytes from source to destination<br>从源主机到目的主机数据的字节数<br><strong>[0 ~ 1379963888]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">dst_bytes</td><td>number of data bytes from destination to source<br>从目的主机到源主机数据的字节数<br><strong>[0 ~ 1309937401]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">flag</td><td>normal or error status of the connection<br>连接状态正常或错误的标志，共11中<br><strong>OTH, REJ, RSTO, RSTOS0, RSTR, S0, S1, S2, S3, SF, SH</strong><br>表示该连接是否按照协议要求开始或完成。例如SF表示连接正常建立并终止；S0表示只接到了SYN请求数据包，而没有后面的SYN/ACK。其中SF表示正常，其他10种都是error。<br>11种状态的详细解释，参考文章[4]</td><td align="center">discrete<br>离散</td></tr><tr><td align="center">land</td><td>1 if connection is from/to the same host/port; 0 otherwise<br> <strong>1:</strong> 连接来自/到同一主机/端口<br> <strong>0:</strong> 其它</td><td align="center">discrete<br>离散</td></tr><tr><td align="center">wrong_fragment</td><td>number of ``wrong’’ fragments<br>“错误”片段的数量<br><strong>[0 ~ 3]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">urgent</td><td>number of urgent packets<br>urgent加急包数量<br><strong>[0 ~ 14]</strong></td><td align="center">continuous<br>连续</td></tr></tbody></table><center><p>Table 1: Basic features of individual TCP connections.</p><p>表1：TCP连接的基本特征</p></center><h2 id="TCP连接的内容特征"><a href="#TCP连接的内容特征" class="headerlink" title="TCP连接的内容特征"></a>TCP连接的内容特征</h2><table><thead><tr><th align="center">feature name</th><th>description</th><th align="center">type</th></tr></thead><tbody><tr><td align="center">hot</td><td>number of ``hot’’ indicators<br>访问系统敏感文件和目录的次数<br><strong>[0 ~ 101]</strong><br>例如访问系统目录，建立或执行程序等</td><td align="center">continuous<br>连续</td></tr><tr><td align="center">num_failed_logins</td><td>number of failed login attempts<br>登录尝试失败的次数。<br><strong>[0 ~ 5]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">logged_in</td><td>1 if successfully logged in<br>0 otherwise<br><strong>1</strong>：成功登录<br><strong>0</strong>：其它</td><td align="center">discrete<br>离散</td></tr><tr><td align="center">num_compromised</td><td>number of ``compromised’’ conditions<br>‘compromised’条件出现的次数<br><strong>[0 ~ 7479]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">root_shell</td><td>1 if root shell is obtained; 0 otherwise<br><strong>1</strong>：获得root shell<br><strong>0</strong>：其它</td><td align="center">discrete<br>离散</td></tr><tr><td align="center">su_attempted</td><td>1 if ``su root’’ command attempted; 0 otherwise<br><strong>1</strong>：出现’su root’<br><strong>0</strong>：其它</td><td align="center">discrete<br>离散</td></tr><tr><td align="center">num_root</td><td>number of ``root’’ accesses<br>root用户访问次数<br><strong>[0 ~ 7468]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">num_file_creations</td><td>number of file creation operations<br>文件创建操作的次数<br><strong>[0 ~ 100]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">num_shells</td><td>number of shell prompts<br>使用shell命令的次数<br><strong>[0 ~ 5]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">num_access_files</td><td>number of operations on access control files<br>访问控制文件的次数<br><strong>[0 ~ 9]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">num_outbound_cmds</td><td>number of outbound commands in an ftp session<br>一个FTP会话种出现连接的次数<br><strong>数据集种这一特征出现次数为0</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">is_hot_login</td><td>1 if the login belongs to the ``hot’’ list; 0 otherwise<br><strong>1</strong>：登录属于’hot’列表<br><strong>0</strong>：其它<br>如超级用户或管理员登录</td><td align="center">discrete<br>离散</td></tr><tr><td align="center">is_guest_login</td><td>1 if the login is a ``guest’’login; 0 otherwise<br><strong>1</strong>：guest登录<br><strong>0</strong>：其它</td><td align="center">discrete<br>离散</td></tr></tbody></table><center><p>Table 2: Content features within a connection suggested by domain knowledge.</p><p>表2：TCP连接的内容特征</p></center><h2 id="基于时间的网络流量统计特征"><a href="#基于时间的网络流量统计特征" class="headerlink" title="基于时间的网络流量统计特征"></a>基于时间的网络流量统计特征</h2><table><thead><tr><th align="center">feature name</th><th>description</th><th align="center">type</th></tr></thead><tbody><tr><td align="center">count</td><td>number of connections to the same host as the current connection in the past two seconds<br><strong>Note:</strong> The following  features refer to these same-host connections.<br>过去两秒内，与当前连接具有相同的目标主机的连接数。<br><strong>[0 ~ 511]</strong><br> <strong>注意：</strong> 以下特征连接到相同主机</td><td align="center">continuous<br>连续</td></tr><tr><td align="center">srv_count</td><td>number of connections to the same service as the current connection in the past two seconds<br><strong>Note:</strong> The following features refer to these same-service connections.<br>过去两秒内，与当前连接具有相同服务的连接数<br><strong>[0 ~ 511]</strong><br> <strong>注意：</strong> 以下特征连接到相同服务</td><td align="center">continuous<br>连续</td></tr><tr><td align="center">serror_rate</td><td>% of connections that have ``SYN’’ errors<br>过去两秒内，在与当前连接具有相同目标主机的连接中，出现“SYN” 错误的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">rerror_rate</td><td>% of connections that have ``REJ’’ errors<br>过去两秒内，在与当前连接具有相同目标主机的连接中，出现“REJ” 错误的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">same_srv_rate</td><td>% of connections to the same service<br>过去两秒内，在与当前连接具有相同目标主机的连接中，与当前连接具有相同服务的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">diff_srv_rate</td><td>% of connections to different services<br>过去两秒内，在与当前连接具有相同目标主机的连接中，与当前连接具有不同服务的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">srv_serror_rate</td><td>% of connections that have ``SYN’’ errors<br>过去两秒内，在与当前连接具有相同服务的连接中，出现“SYN” 错误的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">srv_rerror_rate</td><td>% of connections that have ``REJ’’ errors<br>过去两秒内，在与当前连接具有相同服务的连接中，出现“REJ” 错误的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">srv_diff_host_rate</td><td>% of connections to different hosts<br>过去两秒内，在与当前连接具有相同服务的连接中，与当前连接具有不同目标主机的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center"><font size=2></td><td></td><td align="center"></td></tr></tbody></table><ul><li><p>count、serror_rate、rerror_rate、same_srv_rate、diff_srv_rate这5个特征是 same host特征，前提都是与当前连接具有相同目标主机的连接；</p></li><li><p>srv_count、srv_serror_rate、srv_rerror_rate、srv_diff_host_rate这4个特征是same service特征，前提都是与当前连接具有相同服务的连接。</p></li></ul></font><center>Table 3: Traffic features computed using a two-second time window.<p>表 3：基于时间的网络流量统计特征</p></center><h2 id="基于主机的网络流量统计特征"><a href="#基于主机的网络流量统计特征" class="headerlink" title="基于主机的网络流量统计特征"></a>基于主机的网络流量统计特征</h2><table><thead><tr><th align="center">feature name</th><th>description</th><th align="center">type</th></tr></thead><tbody><tr><td align="center">dst_host_count</td><td>前100个连接中，与当前连接具有相同目标主机的连接数<br><strong>[0 ~ 255]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_srv_count</td><td>前100个连接中，与当前连接具有相同目标主机相同服务的连接数<br><strong>[0 ~ 255]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_same_srv_rate</td><td>前100个连接中，与当前连接具有相同目标主机相同服务的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_diff_srv_rate</td><td>前100个连接中，与当前连接具有相同目标主机不同服务的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_same_src_port_rate</td><td>前100个连接中，与当前连接具有相同目标主机相同源端口的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_srv_diff_host_rate</td><td>前100个连接中，与当前连接具有相同目标主机相同服务的连接中，与当前连接具有不同源主机的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_serror_rate</td><td>前100个连接中，与当前连接具有相同目标主机的连接中，出现SYN错误的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_srv_serror_rate</td><td>前100个连接中，与当前连接具有相同目标主机相同服务的连接中，出现SYN错误的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_rerror_rate</td><td>前100个连接中，与当前连接具有相同目标主机的连接中，出现REJ错误的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_srv_rerror_rate</td><td>前100个连接中，与当前连接具有相同目标主机相同服务的连接中，出现REJ错误的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr></tbody></table><center><p>表 4:基于主机的网络流量统计特征（<a href="http://kdd.ics.uci.edu/databases/kddcup99/task.html">KDD99官网的task部分</a>没找到对应表格）</p></center><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>KDD99在研究者当中十分流行，研究者也对其本身做了很多工作：</p><ul><li>[*]减少特征数量，从最初的41个特征中选择最有用的特征</li><li>[*]指出了KDD99的不足之处<blockquote><ol><li>KDD99面临不平衡的分类方法问题。测试集和训练集的概率分布是不同的，由于在训练集中加入新的攻击，攻击和正常流量的类别的平衡会被打破。[?]</li><li>数据集太老了，可能存在过时的问题</li><li>有研究表明，该数据集存在导致对异常检测性能的过高估计的可能性</li></ol></blockquote></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]. CHAABOUNI N, MOSBAH M, ZEMMARI A, et al. Network Intrusion Detection for IoT Security Based on Learning Techniques [J]. Ieee Communications Surveys and Tutorials, 2019, 21(3): 2671-701.<br>[2]. <a href="http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html">KDD Cup 1999 Data</a><br>[3]. <a href="https://mathpretty.com/10244.html">KDD99数据集与NSL-KDD数据集介绍</a> <em>BTW： 这篇博客对 KDD99 和 NSL-KDD 写的很详细</em><br>[4]. Song J, Takakura H, Okabe Y. Description of kyoto university benchmark data[J]. Available at link: <a href="http://www.takakura.com/Kyoto_data/BenchmarkData-Description-v5.pdf">http://www.takakura.com/Kyoto_data/BenchmarkData-Description-v5.pdf</a> [Accessed on 15 March 2016], 2006.<br>[5]. Özgür A, Erdem H. A review of KDD99 dataset usage in intrusion detection and machine learning between 2010 and 2015[J]. PeerJ Preprints, 2016, 4: e1954v1.</p>]]></content>
    
    
    <categories>
      
      <category>机器学习应用于信息安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KDD99</tag>
      
      <tag>信息安全</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的安装与配置</title>
    <link href="/2021/01/17/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/01/17/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo的安装与初始配置"><a href="#Hexo的安装与初始配置" class="headerlink" title="Hexo的安装与初始配置"></a>Hexo的安装与初始配置</h1><h2 id="一、Hexo安装准备"><a href="#一、Hexo安装准备" class="headerlink" title="一、Hexo安装准备"></a>一、Hexo安装准备</h2><p>安装Hexo的前置需求有：</p><ul><li><strong>Node.js</strong>：主要是使用其中的npm包管理工具（<a href="https://hexo.io/zh-cn/docs/">Hexo官网</a>建议使用Node.js 12.0版本，最低Node.js 10.13） </li><li><strong>Git</strong>：版本控制工具，主要用于博客的版本控制、远端存储和同步</li></ul><h2 id="二、安装Hexo"><a href="#二、安装Hexo" class="headerlink" title="二、安装Hexo"></a>二、安装Hexo</h2><p>安装好上述软件需求后，在shell终端输入以下指令，即可完成安装Hexo。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>安装过程中可能遇到的问题：</p><ol><li>安装过程缓慢或卡在某个过程中不动弹。可以考虑修改npm的默认下载源，如<strong>淘宝镜像源</strong>。</li><li>Windows可以在<strong>Git Bash</strong>中进行类似Linux中的指令。</li></ol><p>安装好hexo之后，如此使用：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ npx hexo &lt;<span class="hljs-keyword">command</span>&gt;<br></code></pre></td></tr></table></figure><p>为了方便起见，我们更倾向于直接使用hexo指令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># hexo <span class="hljs-meta-string">&lt;command&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>方法一：可以考虑将hexo加入PATH</li><li>方法二：设置alias hexo=’npx hexo’</li><li>方法三：(Windows系统)，使用<strong>git bash</strong>貌似可以不用设置环境PATH。但是存在一个小问题，直接运行<strong>git bash</strong>无法正确运行hexo指令，但从文件夹窗口中使用右键菜单<strong>在此处打开git bash</strong>可以直接使用<code>hexo &lt;command&gt;</code></li><li>方法三小问题的原因：<code>hexo &lt;command&gt;</code>需要在blog根目录下执行，因此其它路径会报错。</li></ul><h2 id="三、初始配置"><a href="#三、初始配置" class="headerlink" title="三、初始配置"></a>三、初始配置</h2><p>自此开始，默认使用简化的形式</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ hero &lt;<span class="hljs-keyword">command</span>&gt;<br></code></pre></td></tr></table></figure><p>安装好Hexo之后，要初始化一个工作目录，类似于git中的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>执行指令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;directory&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;directory&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><p>逐条解析：</p><ol><li><code>hexo init &lt;directory&gt;</code>：格式化指定路径为hexo工作目录。</li></ol><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ ll &lt;directory&gt;<br>total 116<br>-rw-r--r--<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span>   <span class="hljs-number"> 0 </span>  _config.landscape.yml<br>-rw-r--r--<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span><span class="hljs-number"> 2545 </span>  _config.yml<br>drwxr-xr-x<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span>   <span class="hljs-number"> 0 </span>  node_modules/<br>-rw-r--r--<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span> <span class="hljs-number"> 641 </span>  package.json<br>-rw-r--r--<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span>57736   package-lock.json<br>drwxr-xr-x<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span>   <span class="hljs-number"> 0 </span>  scaffolds/<br>drwxr-xr-x<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span>   <span class="hljs-number"> 0 </span>  source/<br>drwxr-xr-x<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span>   <span class="hljs-number"> 0 </span>  themes/<br></code></pre></td></tr></table></figure><ol start="2"><li><code>cd &lt;directory&gt;</code>：切换到工作目录</li><li><code>npm install</code>：使用<code>npm</code>根据<code>&lt;directory&gt;</code>中的配置文件下载相关的依赖文件。</li></ol><h2 id="四、个性化设置"><a href="#四、个性化设置" class="headerlink" title="四、个性化设置"></a>四、个性化设置</h2><p>关于hexo博客的个性化设置，离不开<code>&lt;hexo&gt;/_config.yml</code></p><h3 id="1、设置博客标题、基本信息等"><a href="#1、设置博客标题、基本信息等" class="headerlink" title="1、设置博客标题、基本信息等"></a>1、设置博客标题、基本信息等</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">$ vim _config.yml<br>...<br><span class="hljs-comment"># Site</span><br><span class="hljs-section">title: 设置博客标题</span><br><span class="hljs-section">subtitle: &#x27;&#x27;</span><br><span class="hljs-section">description: &#x27;&#x27;</span><br><span class="hljs-section">keywords:</span><br><span class="hljs-section">author: 作者姓名</span><br><span class="hljs-section">language: 语言，中文设置为zh即可</span><br><span class="hljs-section">timezone: 国内一般使用Asia/Shanghai即可</span><br>...<br></code></pre></td></tr></table></figure><p>此处抛砖引玉，更多相关设置使用时实时查阅即可</p><h3 id="2、设置博客主题-theme"><a href="#2、设置博客主题-theme" class="headerlink" title="2、设置博客主题(theme)"></a>2、设置博客主题(theme)</h3><p><a href="https://hexo.io/zh-cn/">Hexo官网</a>共享了很多主题。</p><p><img src="https://gitee.com/songz7026/image-pool/raw/master/note_hexo/hexo_theme.png" alt="Hexo官网主题"></p><p>任选一款进入，即可找到作者的github主页连接，在其中寻找hexo的主题仓库即可，一般在readme中都会详细介绍主题的安装方法。不过一般来说都是一样的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> &lt;directory&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> &lt;github_theme仓库的连接&gt;</span><br></code></pre></td></tr></table></figure><p>在此之后修改<code>_config.yml</code>中的<code>theme</code>即可</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"># Extensions<br>## Plugins: https:<span class="hljs-comment">//hexo.io/plugins/</span><br>## Themes: https:<span class="hljs-comment">//hexo.io/themes/</span><br>theme: 这里这里这里 theme名称填上去就可以了<br></code></pre></td></tr></table></figure><p>个别theme会有自己的安装方法，按照readme详细做就可以了。</p><h2 id="五、查看博客"><a href="#五、查看博客" class="headerlink" title="五、查看博客"></a>五、查看博客</h2><p>在shell中键入以下指令即可开启本地服务，从本地浏览器输入对应连接(下文对应链接为localhost:4000)即可查看</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ hexo <span class="hljs-keyword">server</span><br><span class="hljs-keyword">INFO</span>  Validating config<br><span class="hljs-keyword">INFO</span>  <span class="hljs-keyword">Start</span> processing<br><span class="hljs-keyword">INFO</span>  Hexo <span class="hljs-keyword">is</span> running at http://localhost:<span class="hljs-number">4000</span> . Press Ctrl+C <span class="hljs-keyword">to</span> stop.<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/songz7026/image-pool/raw/master/note_hexo/hexo_init_blog.png" alt="初始状态博客首页"></p><p>使用<code>-o</code>选项可以自动使用系统默认浏览器打开</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span> -o<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
