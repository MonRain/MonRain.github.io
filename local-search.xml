<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python异常检测开源工具包</title>
    <link href="/2021/02/15/Python%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    <url>/2021/02/15/Python%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="异常检测的工具包PyOD"><a href="#异常检测的工具包PyOD" class="headerlink" title="异常检测的工具包PyOD"></a>异常检测的工具包PyOD</h1><p><a href="https://github.com/yzhao062/pyod">GitHub项目地址</a><br><a href="https://pyod.readthedocs.io/en/latest/">文档地址</a></p><p><code>PyOD</code>是在<code>sklearn</code>基础上开发的异常检测工具包，<a href="https://pyod.readthedocs.io/en/latest/#implemented-algorithms">涉及到的检测方法</a>分为三类：</p><ol><li>Individual Detection Algorithms</li><li>Outlier Ensembles &amp; Outlier Detector Combination Frameworks</li><li>Utility Functions</li></ol><p>美中不足在于所涉及的所有算法均是<code>offline</code>模式，无法满足增量学习（在线学习）的测试需求。（尽管部分模型中存在<code>partial_fit()</code>方法）</p><h1 id="增量学习（在线学习）的异常检测工具包PySAD"><a href="#增量学习（在线学习）的异常检测工具包PySAD" class="headerlink" title="增量学习（在线学习）的异常检测工具包PySAD"></a>增量学习（在线学习）的异常检测工具包PySAD</h1><p><a href="https://github.com/selimfirat/pysad">GitHub项目地址</a><br><a href="https://pysad.readthedocs.io/en/latest/">文档地址</a></p><p><code>PySAD</code>也是在<code>sklearn</code>基础上开发的异常检测工具包，同时也向<code>PyOD</code>兼容，<a href="https://pysad.readthedocs.io/en/latest/examples.html#example-pyod-integration">提供了与PyOD协作的方法</a>。</p><p><a href="https://pysad.readthedocs.io/en/latest/api.html#api-reference">涉及到的检测方法</a>可以从官方的API文档中查看。</p><h1 id="兼顾离线学习于在线学习的检测工具包alibi-detect"><a href="#兼顾离线学习于在线学习的检测工具包alibi-detect" class="headerlink" title="兼顾离线学习于在线学习的检测工具包alibi-detect"></a>兼顾离线学习于在线学习的检测工具包alibi-detect</h1><p><a href="https://github.com/SeldonIO/alibi-detect">GitHub项目地址</a><br><a href="https://docs.seldon.io/projects/alibi-detect/en/latest/">文档地址</a></p><p>并未经过实际测试应用，了解不多。</p><p>需要更多详情可以参考项目仓库和文档。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>日积月累</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python将list中str转换为数字 —— map()函数使用方法</title>
    <link href="/2021/02/15/Python%E5%B0%86list%E4%B8%ADstr%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E2%80%94%E2%80%94map()%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2021/02/15/Python%E5%B0%86list%E4%B8%ADstr%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E2%80%94%E2%80%94map()%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Python将list中str转换为数字-——-map-函数使用方法"><a href="#Python将list中str转换为数字-——-map-函数使用方法" class="headerlink" title="Python将list中str转换为数字 —— map()函数使用方法"></a>Python将list中str转换为数字 —— map()函数使用方法</h1><h2 id="问题：list中str转换为数字"><a href="#问题：list中str转换为数字" class="headerlink" title="问题：list中str转换为数字"></a>问题：list中str转换为数字</h2><p>问题描述：若在数据处理过程中，遇到一个list变量</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;23&#x27;</span>, <span class="hljs-string">&#x27;43&#x27;</span>, <span class="hljs-string">&#x27;24&#x27;</span>]</span><br></code></pre></td></tr></table></figure><p>其中的元素都为<code>str</code>类型，但数据处理需要数字类型，因此需要做进一步转化</p><p>我们利用迭代映射函数<code>map()</code>，先看一下<code>map()</code>函数的功能：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">map</span>(<span class="hljs-params">function, iterable, ...</span>)</span><br></code></pre></td></tr></table></figure><ul><li><code>function</code>, 对后边对象需要进行的操作</li><li><code>iterable</code>, 希望被操作的对象</li></ul><p><strong>注意</strong>：<code>map()</code>函数在Python 2和Python 3中存在微小的差别：</p><ul><li>Python 2返回操作后得到的list</li><li>Python 3返回迭代器</li></ul><p>结合当前问题体会一下<code>map()</code>函数的操作</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"># Python 2<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;23&#x27;</span>, <span class="hljs-string">&#x27;43&#x27;</span>, <span class="hljs-string">&#x27;24&#x27;</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,a)</span><br>[2, 23, 43, 24]<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>,a)</span><br>[2.0, 23.0, 43.0, 24.0]<br><br># Python 3: 需要使用list将map()返回的迭代器转换为list对象<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;23&#x27;</span>, <span class="hljs-string">&#x27;43&#x27;</span>, <span class="hljs-string">&#x27;24&#x27;</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,a))</span><br>[2, 23, 43, 24]<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>,a))</span><br>[2.0, 23.0, 43.0, 24.0]<br></code></pre></td></tr></table></figure><p>相当于对<code>a</code>中每一个元素都进行了<code>int(x)</code>/<code>float(x)</code>操作</p><h2 id="map-函数的引申使用"><a href="#map-函数的引申使用" class="headerlink" title="map()函数的引申使用"></a>map()函数的引申使用</h2><p>我们可以利用<code>map()</code>进行更多自定义操作</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">b=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]</span><br><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span>(<span class="hljs-params">x</span>):</span></span><br>return x+1<br><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(fun,b))</span><br>[2, 3, 4, 5]<br># 或使用lambda匿名函数<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x+<span class="hljs-number">2</span>,b))</span><br>[3, 4, 5, 6]<br><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">c = [<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x, y: x + <span class="hljs-number">2</span> * y, b, c))</span><br>[15, 14, 11, 10]<br></code></pre></td></tr></table></figure><p><strong>参考</strong></p><p><a href="https://www.runoob.com/python/python-func-map.html">Python map() 函数</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>日积月累</tag>
      
      <tag>map()</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python获取list特定元素下标</title>
    <link href="/2021/02/15/Python%E8%8E%B7%E5%8F%96list%E7%89%B9%E5%AE%9A%E5%85%83%E7%B4%A0%E4%B8%8B%E6%A0%87/"/>
    <url>/2021/02/15/Python%E8%8E%B7%E5%8F%96list%E7%89%B9%E5%AE%9A%E5%85%83%E7%B4%A0%E4%B8%8B%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="python获取list特定元素下标"><a href="#python获取list特定元素下标" class="headerlink" title="python获取list特定元素下标"></a>python获取list特定元素下标</h1><p>反索引，一般情况我们通过索引获取list中的元素。<br>如：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a[<span class="hljs-number">3</span>]</span><br>4<br></code></pre></td></tr></table></figure><p>有些时候，我们已知list中的某些元素，但需要通过已知元素获得其在list中的索引位置。</p><h2 id="方法1：利用builtin方法item-index-list"><a href="#方法1：利用builtin方法item-index-list" class="headerlink" title="方法1：利用builtin方法item.index(list)"></a>方法1：利用builtin方法item.index(list)</h2><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a.index(<span class="hljs-number">3</span>)</span><br>2<br></code></pre></td></tr></table></figure><p><strong>注意</strong> 如果list中存在重复值，这个方法只能获得第一个值的index。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a.index(<span class="hljs-number">2</span>)</span><br>0<br></code></pre></td></tr></table></figure><h2 id="方法2：enumerate-方法"><a href="#方法2：enumerate-方法" class="headerlink" title="方法2：enumerate()方法"></a>方法2：enumerate()方法</h2><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">e=<span class="hljs-built_in">enumerate</span>(a)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">e</span><br>&lt;enumerate object at 0x000001A6FF29D7C0&gt;<br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-built_in">list</span>(e)</span><br>[(0, 2), (1, 1), (2, 3), (3, 2), (4, 6)]<br></code></pre></td></tr></table></figure><p>不难发现，<code>enumerate()</code>方法包含的值的形式为</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">(<span class="hljs-keyword">index</span> <span class="hljs-number">0</span>, value <span class="hljs-number">0</span>),(<span class="hljs-keyword">index</span> <span class="hljs-number">1</span>, value <span class="hljs-number">1</span>),(<span class="hljs-keyword">index</span> <span class="hljs-number">2</span>, value <span class="hljs-number">2</span>)...<br></code></pre></td></tr></table></figure><p>可以通过利用这个信息获得元素的index</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">print([i <span class="hljs-keyword">for</span> i,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a) <span class="hljs-keyword">if</span> x==<span class="hljs-number">2</span>])</span><br>[0, 3]<br></code></pre></td></tr></table></figure><p><strong>参考</strong><br><a href="https://blog.csdn.net/qq_24737639/article/details/78839678">python 获取list特定元素下标</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>日积月累</tag>
      
      <tag>list查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础笔记</title>
    <link href="/2021/02/15/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/02/15/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java语言基础笔记"><a href="#Java语言基础笔记" class="headerlink" title="Java语言基础笔记"></a>Java语言基础笔记</h1><h3 id="interface-￼接口"><a href="#interface-￼接口" class="headerlink" title="interface ￼接口"></a>interface ￼接口</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">￼[可见度] <span class="hljs-keyword">interface</span> 接口名称 <span class="hljs-symbol">extend</span> 其他接口&#123;<br><span class="hljs-comment">// 声明变量</span><br><span class="hljs-comment">// 抽象方法</span><br>&#125; <br></code></pre></td></tr></table></figure><p>interface接口可以理解为一种特殊的抽象类，对抽象类进一步特殊化，是抽象方法的集合。</p><p>接口不可以被*<strong>实例化**<em>，但可以被</em></strong>实现***。但是Java 8之后改进为允许定义默认方法和实现<br>更过详见gitee的wiki——《抽象类与接口》</p><h3 id="container-容器"><a href="#container-容器" class="headerlink" title="container 容器"></a>container 容器</h3><p>container内容比较复杂，简单来说，是Java为开发者提前造好的轮子，就字面意思理解为==存放数据的容器==，解决基本数据类型（如数组）不能解决的问题。</p><p>此外还会涉及到数据结构、线程安全等的问题。</p><p>常用的部分container</p><blockquote><p>Collection **==元素==**的集合</p><blockquote><p>一、List 元素可重复</p></blockquote></blockquote><p><code>List.toArray()把List转化为Array（Object数组）</code></p><blockquote><blockquote><blockquote><p><del>1. Vector：已经被弃用(From JDK1.5)，<strong>线程同步</strong></del></p><blockquote><p><del>Stack：是满足后进先出的容器，但LinkedList可以实现所有栈功能</del></p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><ol start="2"><li>ArrayList：可以<strong>动态增长</strong>的数组，默认长度是10。<br>随机访问快，插入删除慢。</li><li><strong>LinkedList：同时属于Collection和Queue）</strong> ：用<strong>链表</strong>实现的容器。<strong>可以实现很多队列、栈的数据结构。</strong><br>查找慢（遍历整个链表），插入删除快。</li></ol></blockquote></blockquote></blockquote><blockquote><blockquote><p>二、Queue 队列 先进后出FILO</p><blockquote><p><strong>LinkedList （同时属于Collection和Queue）</strong><br>PriorityQueue 优先级队列</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>三、Set 集合 元素不可重复</p><blockquote><ol><li>HashSet：底层使用散列函数，查询方面有优化<blockquote><p> LinkHashSet</p></blockquote></li></ol></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><ol start="2"><li>TreeSet：底层使用红黑树</li></ol></blockquote></blockquote></blockquote><blockquote><p>Map **==键值对==**的集合</p><blockquote><ol><li>HashMap 适合查找、删除、插入</li><li>TreeMap 适合遍历</li></ol></blockquote></blockquote><p>上述表述极不全面，待补充。</p><h3 id="多态Polymorphism"><a href="#多态Polymorphism" class="headerlink" title="多态Polymorphism"></a>多态Polymorphism</h3><p>多态指的是一个<strong>引用</strong>变量在程序中可以充当多种角色。细化地讲，比如可以将一个类的引用变量赋值为其子类的实例，如代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Animal.class是Cat.class Pig.class的* 父类</span><br><span class="hljs-comment">*/</span><br>Animal an1;<br>Animal an2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Animal</span>();<br>Animal an3 = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>();<br>Animal an4 = <span class="hljs-keyword">new</span> <span class="hljs-type">Pig</span>();<br></code></pre></td></tr></table></figure><p>在多态问题中，还存在函数调用的问题：</p><ul><li>如上例语句3中，an3只能调用Animal的方法，因为不能保证Animal中有子类的方法。只有声明部分明确声明为子类类型时，其引用变量才能调用对应子类的方法</li><li><strong>动态调用</strong>问题：若子类和父类同时含有相同名称的方法，默认调用最能体现具体特点的子类方法。</li></ul><p>instanceof运算符能判断具体的实例是否满足某个特定的类型。</p><h3 id="异常Exception"><a href="#异常Exception" class="headerlink" title="异常Exception"></a>异常Exception</h3><h5 id="异常的介绍"><a href="#异常的介绍" class="headerlink" title="异常的介绍"></a>异常的介绍</h5><p>Java中所有能被抛出的对象都视为Throwable类的实例，Exception和Error都是Throwable类的子类。<br>其中：</p><ul><li>Error表示程序遇到的严重错误，几乎无法挽回。</li><li>Exception程度轻一点，比如打开一个不存在的文件。</li></ul><p>进一步地，Java将运行时异常(RuntimeException)定性为非检查性异常(unchecked exceptions)，而所有其它异常定性为检查性异常(checked exceptions)。<br><strong>前者</strong>在运行时出现，由于运行程序的各种不可预见性，所以称之为“unchecked”。<br><strong>后者</strong>在程序开发中可预见，因此称之为“checked”（有些不运行就难以发现的异常也是checked异常）。</p><p>可以通过继承来定义新的异常类型。</p><h5 id="异常的抛出与处理"><a href="#异常的抛出与处理" class="headerlink" title="异常的抛出与处理"></a>异常的抛出与处理</h5><p>在异常问题中，事件的主体有两个：</p><ul><li>代码：代码中可以编写有效获取并处理异常的程序。</li></ul><p>代码主动进行异常抛出使用<code>throw new ExceptionType();</code><br>在函数声明时也可以使用<code>throws</code>来声明此函数可能抛出的异常类别：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">abc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException,NullPointerException</span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>JVM：当出现代码中未处理的异常时，JVM会在打印运行时的堆栈跟踪信息之后终止程序的运行。如下段代码所示（例）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> &quot;<span class="hljs-selector-tag">main</span>&quot; <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NullPointerException</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.toArray</span>(<span class="hljs-selector-tag">ArrayList</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:358)</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">net</span><span class="hljs-selector-class">.datastructures</span><span class="hljs-selector-class">.HashChainMap</span><span class="hljs-selector-class">.bucketGet</span>(<span class="hljs-selector-tag">HashChainMap</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:35)</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">net</span><span class="hljs-selector-class">.datastructures</span><span class="hljs-selector-class">.AbstractHashMap</span><span class="hljs-selector-class">.get</span>(<span class="hljs-selector-tag">AbstractHashMap</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:62)</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">dsaj</span><span class="hljs-selector-class">.design</span><span class="hljs-selector-class">.Demonstration</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">Demonstration</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:12)</span><br></code></pre></td></tr></table></figure><p>需要注意的是，在堆栈的跟踪信息中，每一步都有机会获取(catch)和处理异常，下级未处理的异常会被传递给上级调用函数，当异常层层上报都没有被有效处理，JVM就要插手打印信息并终止程序。<br>JVM在不经过代码时也可能抛出异常（如堆栈溢出）。</p><p>正确的异常处理方法为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span>&#123;<br>expressions;<br>&#125; <span class="hljs-keyword">catch</span>(EXCEPTIONtype1 e)&#123;<br>expressions;<br>&#125; <span class="hljs-keyword">catch</span>(EXCEPTIONtype2 e)&#123;<br>expressions;<br>&#125; <span class="hljs-keyword">catch</span>(EXCEPTIONtype3 e)&#123;<br>expressions;<br>&#125;...<br>...<br>final&#123;<br>expressions;<br>&#125;<br></code></pre></td></tr></table></figure><p> 值得注意的是，从JDK SE 7开始，允许catch中异常类型的合并：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><br><span class="hljs-keyword">try</span>&#123;<br>expressions;<br>&#125; <span class="hljs-keyword">catch</span>(EXCEPTIONtype1| EXCEPTIONtype2| EXCEPTIONtype3 e)&#123;<br>expressions;<br>&#125;<br>...<br><span class="hljs-keyword">final</span>&#123;<br>expressions;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样是从JDK SE7开始，尝试了一种新的“try with resource”(尚未研究，略）</p><h3 id="强制类型转换与泛型"><a href="#强制类型转换与泛型" class="headerlink" title="强制类型转换与泛型"></a>强制类型转换与泛型</h3><h4 id="强制类型转换Casting"><a href="#强制类型转换Casting" class="headerlink" title="强制类型转换Casting"></a>强制类型转换Casting</h4><p>主要关注引用类型的强制类型转换问题，一般包含两个子问题：</p><ul><li>widening casting：<strong>具体-&gt;抽象</strong>，向上转换</li></ul><p>从 <strong>低层次</strong> 类型T转换为 <strong>高层次</strong> 类型U。一般有以下三种情况：</p><blockquote><p>子类对象T 转换为 父类对象U<br>子接口T 转换为 父接口U<br>T使用了接口U</p></blockquote><p><em>类似多态问题</em></p><ul><li>narrow casting ：<strong>抽象-&gt;具体</strong>，向下转换</li></ul><p>从 <strong>高层次</strong> 类型T转换为 <strong>低层次</strong> 类型U。一般有以下三种情况：</p><blockquote><p>父类对象T 转换为 子类对象U<br>父接口T 转换为 子接口U<br>U使用了接口T</p></blockquote><p>一般来说，向上转换比较安全，编译器可以自动认定转换的正确性，但向下转换不行。</p><p>因此产生了运算符**<code>instanceof</code>**，语法为</p><p><strong><code>Obj instanceof Type</code></strong></p><p>当强制转换出现问题时，会出现<code>ClassCastException</code>异常</p><h4 id="泛型Generics"><a href="#泛型Generics" class="headerlink" title="泛型Generics"></a>泛型Generics</h4><p>泛型产生的对应需求是，需要将同一类功能实现到不同类型的数据上，而不针对每个特定的类型都造出重复的车轮子。</p><ul><li>泛型的前世</li></ul><p>泛型时自Java SE 5才开始有的，在此之前，使用Object类进行相似功能，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>Object A;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(Object a)</span></span>&#123;<br>A = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Method</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> A;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于Object的所有类型的父类（超类），因此可以接受所有类型的向上强制类型转换，所以看上去是个很好的选择，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br>String str = “hello”<br><span class="hljs-keyword">public</span> Test test = <span class="hljs-keyword">new</span> Test(str);<br>String ret = test.Method();<br>...<br></code></pre></td></tr></table></figure><p>上述代码的初衷在于使用一个String类型创建一个Test实例test，然后获取其中存储的内部变量赋值给String对象ret。</p><p>但事实上，这是不安全的甚至编译不会通过，因为在最后一行代码中，涉及到了将test对象内部存储的Object对象test.A向下转换到类型String，因此需要显示强制类型转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">String ret = (String) test.Method();<br></code></pre></td></tr></table></figure><ul><li>Java SE 5 之后到泛型</li></ul><p>泛型支持在类型定义中使用参数化的类型定义变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>T A;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(Object a)</span></span>&#123;<br>A = a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Method</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> A;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，声明了一个参数化类型T，并且在内部代码中视为一个已知类型使用，在实例化和后续使用时，如示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java">...<br>String str = “hello”<br><span class="hljs-keyword">public</span> Test&lt;String&gt; test;<br>test = <span class="hljs-keyword">new</span> Test&lt;String&gt;(str);<span class="hljs-comment">// 可选1</span><br>test = <span class="hljs-keyword">new</span> Test&lt;&gt;(str);<span class="hljs-comment">// 可选2</span><br>String ret = test.Method();<br>...<br></code></pre></td></tr></table></figure><p>上述代码中，声明Test类型的实例test时，指定了Test内部的参数化类型为String，因此在实例test内部将T类型视为String类型，所以对于方法test.Method()返回的也自然就是String类型的对象，不需要进行类型转换了。</p><p>按照代码书写惯例，参数化类型一般采用单个大写字母。</p><p>需要注意的是，代码中“可选1”和“可选2”是两种实例化方法，最初是使用“可选1”的风格。在Java SE 7之后为了简化，采用了“可选2”的风格，这种风格也常被称为“菱形语法”，赋值时自动匹配待赋值引用变量声明时所规定的泛型类型。</p><p>如果没有指定类型<code>test = new Test(str)</code>，则视为使用经典类型（Java SE 5 之前），泛型被视为指定成Object类型</p><p>泛型不接受基本类型的制定，如double需要制定为其包装类型Double。</p><ul><li>泛型与数组联合使用的风险</li></ul><p>泛型对象和数组一起使用时存在不安全的风险，具体来讲，Java允许使用带泛型的数组声明，但是不允许在实例化(new)的时候生成泛型实例直接赋值给数组。可以接受的折衷办法是使用旧版方法（不使用菱形语法）然后经过强制类型转换赋值给对应数组，尽管此办法可行，但编译时仍会报出warning，因为这是不安全的。一般以下两种情况会遇到此风险。</p><p>-&gt; 外部创建泛型类的数组</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Test&lt;A&gt;<span class="hljs-comment">[]</span> tests<br>tests = new Test&lt;A&gt;<span class="hljs-comment">[10]</span>;<span class="hljs-comment">[错]</span><br>tests = new Test<span class="hljs-comment">[10]</span>;<span class="hljs-comment">[对]</span><br>tests<span class="hljs-comment">[0]</span> = new Test&lt;A&gt;;<span class="hljs-comment">[对]</span><br></code></pre></td></tr></table></figure><p>-&gt; 泛型类内部创建泛型类数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">A</span>&gt;</span>&#123;<br>A[] a;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Test</span>(<span class="hljs-params"></span>)</span>&#123;<br>a = <span class="hljs-keyword">new</span> A[<span class="hljs-number">10</span>];[错]<br>a = (A[]) <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>[<span class="hljs-number">10</span>][对]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法中使用泛型</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Test()<span class="hljs-comment">&#123;</span><br><span class="hljs-comment">public &lt;A&gt; void method(A[] a)&#123;</span><br><span class="hljs-comment">A temp=a[0];</span><br><span class="hljs-comment">&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>限定泛型范围</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-title">&lt;A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExistClass&gt;</span></span><br></code></pre></td></tr></table></figure><p>将泛型A可以指定的类型范围强制限定为某个已知的类型范围内，保证内部某些方法的可用性。</p><h3 id="反射Reflect"><a href="#反射Reflect" class="headerlink" title="反射Reflect"></a>反射Reflect</h3><p>代码引入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//对于一个类Test</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-comment">//定义方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method4</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-comment">//定义构造器</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br>Test()&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br><span class="hljs-comment">//定义属性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> d = <span class="hljs-number">2.1</span>;<br>&#125;<br><br><span class="hljs-comment">//正常使用</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test01</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>Test test = <span class="hljs-keyword">new</span> Test();<br>test.method1(); <br>&#125;<br>&#125;<br><span class="hljs-comment">//使用反射</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test02</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>Class cls = Class.forName(“com.xxx.xxx.Test”);<br>Object o = cls.newInstance();<br>Method m1 = c.getMethod(“Method01”);<br>m1.invoke(o);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>乍一看很蒙，这就是反射的第一印象，这东西不理解的时候看起来很蒙，理解之后看起来就很容易懂了。</p><h4 id="反射的理解层面"><a href="#反射的理解层面" class="headerlink" title="反射的理解层面"></a>反射的理解层面</h4><h4 id="反射的具体使用"><a href="#反射的具体使用" class="headerlink" title="反射的具体使用"></a>反射的具体使用</h4><h5 id="获取Class类对象（字节码信息）的几种方法"><a href="#获取Class类对象（字节码信息）的几种方法" class="headerlink" title="获取Class类对象（字节码信息）的几种方法"></a>获取Class类对象（字节码信息）的几种方法</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//方式1:通过具体实例对象的getClass()方法</span><br>Test test1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Test()</span>;<br>Class cls1 = test1.get<span class="hljs-constructor">Class()</span>;<br><span class="hljs-comment">//方式2:通过具体类的内置静态class属性</span><br>Class cls2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span><span class="hljs-keyword">class</span>;<br><span class="hljs-comment">//方式3:通过Class类的静态方法forName()方法[- 最常用 -]</span><br>Class cls3 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(“<span class="hljs-params">com</span>.<span class="hljs-params">xxx</span>.<span class="hljs-params">xxx</span>.Test”)</span>;<br><span class="hljs-comment">//方式4:通过类的加载器</span><br>ClassLoader cloader = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">ClassLoader()</span>; <br>Class cls4 = loader.load<span class="hljs-constructor">Class(“<span class="hljs-params">com</span>.<span class="hljs-params">xxx</span>.<span class="hljs-params">xxx</span>.Test”)</span>;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>若判断<code>cls1==...==cls4</code>会返回<code>true</code>，因为他们都代表同一个类别Test的字节码。</li><li>方法3是最常用的，用于动态指定操作的类、对象、方法等。由于其他三种方法中都已经包含指定特定的类、对象、方法进行操作，一般不会应用到反射的最大应用场景——动态指定类和对象。</li></ul><h5 id="获取类的构造器以及对象的创建"><a href="#获取类的构造器以及对象的创建" class="headerlink" title="获取类的构造器以及对象的创建"></a>获取类的构造器以及对象的创建</h5><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">Class</span> c = <span class="hljs-keyword">Class</span>.forName(“com.xxx.xxx.Test”);<br><br><span class="hljs-comment">//获取包括其父类在内的所有public构造器</span><br><span class="hljs-function"><span class="hljs-keyword">Constructor</span>[] <span class="hljs-title">cons</span> = <span class="hljs-title">c</span>.<span class="hljs-title">getConstructors</span><span class="hljs-params">()</span>;</span><br><span class="hljs-comment">//获取包括其父类在内的所有构造器（不局限于public）</span><br><span class="hljs-comment">//public protected default private都可以获取到</span><br><span class="hljs-function"><span class="hljs-keyword">Constructor</span>[] <span class="hljs-title">cons</span> = <span class="hljs-title">c</span>.<span class="hljs-title">getDeclaredConstructors</span><span class="hljs-params">()</span>;</span><br><br><span class="hljs-comment">//获取特定构造器</span><br><span class="hljs-comment">//若需要获取的构造器非pubilc，需要使用getDeclaredConstructor(&lt;Class&gt;);</span><br><span class="hljs-comment">//根据参数列表区分不同构造器</span><br><span class="hljs-function"><span class="hljs-keyword">Constructor</span> <span class="hljs-title">cons1</span> = <span class="hljs-title">c</span>.<span class="hljs-title">getConstructor</span><span class="hljs-params">(int.<span class="hljs-keyword">class</span>, double.<span class="hljs-keyword">class</span>, SpecificClass)</span>;</span><br><br><span class="hljs-comment">//创建对象：使用构造器创建对象</span><br><span class="hljs-keyword">Object</span> o = cons1.newInstance();<br><br></code></pre></td></tr></table></figure><h5 id="获取类的属性和赋值"><a href="#获取类的属性和赋值" class="headerlink" title="获取类的属性和赋值"></a>获取类的属性和赋值</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Class c = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(“<span class="hljs-params">com</span>.<span class="hljs-params">xxx</span>.<span class="hljs-params">xxx</span>.Test”)</span>;<br><br>Field<span class="hljs-literal">[]</span> feilds = c.get<span class="hljs-constructor">Feilds()</span>;<br>Field age = c.get<span class="hljs-constructor">Feild(“<span class="hljs-params">age</span>”)</span>;<br><span class="hljs-comment">//同理若需要非public属性时</span><br>Field<span class="hljs-literal">[]</span> feilds = c.get<span class="hljs-constructor">DeclaredFeilds()</span>;<br>Field size = c.get<span class="hljs-constructor">DeclaredFeild(“<span class="hljs-params">bombsize</span>”)</span>;<br><br><span class="hljs-comment">//还可以获取属性的修饰符、数据类型……</span><br><br>size.get<span class="hljs-constructor">Modifiers()</span>;<br>size.get<span class="hljs-constructor">Name()</span>;<br>size.get<span class="hljs-constructor">Type()</span>;<br><br><span class="hljs-comment">//给属性赋值</span><br>size.set(??,<span class="hljs-number">34</span>);<span class="hljs-comment">//Error!</span><br><br>Object oset = cons1.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>size.set(oset, <span class="hljs-number">34</span>);<span class="hljs-comment">//valid</span><br></code></pre></td></tr></table></figure><h5 id="获取类的方法和调用"><a href="#获取类的方法和调用" class="headerlink" title="获取类的方法和调用"></a>获取类的方法和调用</h5><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Class</span> c = <span class="hljs-keyword">Class</span>.forName(“com.xxx.xxx.Test”);<br><br><span class="hljs-function"><span class="hljs-keyword">Method</span>[] <span class="hljs-title">m1</span> = <span class="hljs-title">c</span>.<span class="hljs-title">getMethods</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-keyword">Method</span> <span class="hljs-title">m2</span> = <span class="hljs-title">c</span>.<span class="hljs-title">getMethod</span><span class="hljs-params">(“methodName”)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">Object</span> <span class="hljs-title">o</span> = <span class="hljs-title">cons1</span>.<span class="hljs-title">newInstance</span><span class="hljs-params">()</span>;</span><br>m2.Invoke(o);<br></code></pre></td></tr></table></figure><h4 id="反射值得思考的问题"><a href="#反射值得思考的问题" class="headerlink" title="反射值得思考的问题"></a>反射值得思考的问题</h4><ul><li>简而言之，反射的用法很多，功能很强大，除上述用法之外，还可以获得其父类、接口、注解等一系列信息，具体实现方法可以参考API文档。</li><li>反射的规律性，反射的功能很多，但是从规律上而言，大致可以这么看：批量获取所有目标可以调用getXxxs()或者getDeclaredXxxs()方法，获取单个目标可以调用不带s版本的对应方法。获取public目标可以调用getXxxs() 或者getXxx(…)，获取非public目标可以调用对应方法的Declared版本。</li><li>反射是否破坏了面向对象的封装？回答：事实上确实破坏了，但是反射有它自己的实现环境，迎合了一部分需求。应该尽量保持面向对象的封装型，但在一定的需求情况下考虑变通。打个比方，1、男生不能进女厕所，2、女生不能进男生宿舍。</li></ul><h3 id="注解Annotation"><a href="#注解Annotation" class="headerlink" title="注解Annotation"></a>注解Annotation</h3><h4 id="注解的理解层面"><a href="#注解的理解层面" class="headerlink" title="注解的理解层面"></a>注解的理解层面</h4><p>严格来说，注解对程序的逻辑实现没什么用。注解起到的作用是，在程序中充当<strong>提醒</strong>的角色，提醒程序猿、编译器等一系列让程序debug向正常运行方向的主体。<br>比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method1</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的目的是重写某个主体内部的method1()方法。如果程序猿不写@Override，程序也能正常编译，如果逻辑没问题的话正常运行。但是一旦程序猿犯困，嘛method1方法名写错了，如果不写@Override的话，程序会继续创建一个新方法，默默无闻，傻不拉几；如果@Override存在，编译器会发现卧槽，你这方法我以前没见过，怎么重写？是不是你拼错了还是发生了啥？醒醒！</p><h4 id="常用的三个注解"><a href="#常用的三个注解" class="headerlink" title="常用的三个注解"></a>常用的三个注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Override</span><span class="hljs-comment">//重写方法</span><br><span class="hljs-meta">@Deprecated</span><span class="hljs-comment">//标记已经被淘汰的方法</span><br><span class="hljs-meta">@SuppressWarning</span><span class="hljs-comment">//标记以抑制编译器警告</span><br></code></pre></td></tr></table></figure><h4 id="注解的自定义"><a href="#注解的自定义" class="headerlink" title="注解的自定义"></a>注解的自定义</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">public @interface Haha()&#123;<br><span class="hljs-regexp">//</span>看上去是无参数方法，实际上理解成一个成员变量<br><span class="hljs-regexp">//</span>约定俗成如果只有一个无参数方法（）就命名为value<br><span class="hljs-regexp">//</span>String[]成员变量返回值（类型） value成员变量的名称 <br>String[] value();<br><span class="hljs-regexp">//</span>内部定义参数的注解——标记<br><span class="hljs-regexp">//</span>内部没有定义参数的注解——元数据<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java">标记注解的注解——元注解<br><span class="hljs-meta">@Retention</span>注解存活时间：源代码、编译、运行<br><span class="hljs-meta">@Target</span>注解的使用范围：类型、属性、方法……<br><span class="hljs-meta">@Documented</span>注解是否被收入文档<br><span class="hljs-meta">@Inherited</span>继承于被标记的注解也会继承注解<br>相应的参数查看源码即可得<br></code></pre></td></tr></table></figure><h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><p>Java的IO的四大基类<br><img src="https://i.loli.net/2020/11/14/SKMlFCAeRzQb3qH.jpg" alt="Alt"></p><h4 id="File类-java-io-File"><a href="#File类-java-io-File" class="headerlink" title="File类(java.io.File)"></a>File类(java.io.File)</h4><p>File类的理解：将系统中的文件、文件夹抽象为File类（联想到Linux系统中“万物皆文件”），如无特殊说明，本段后续统称文件和文件夹为<strong>文件</strong>。</p><h5 id="File类的基本使用："><a href="#File类的基本使用：" class="headerlink" title="File类的基本使用："></a>File类的基本使用：</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake">/* 创建一个关联于某个路径的<span class="hljs-keyword">file</span>对象<br>* 理解：这里只是在程序中创建了一个对象，对象指向了某个路径。<br>* 至于这个路径到底正确与否、存在与否，至少到这里程序是不关心的。<br>* 相当于在程序中写入了一个地址记录，至于地址到底有没有人，有没有房子，那是以后的事，这里只是在纸上写了一行字<br>* /<br><span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> = new <span class="hljs-keyword">File</span>(“PATH”);<br>// 可以通过这个对象对指定文件进行一系列操作<br><span class="hljs-keyword">String</span> name = <span class="hljs-keyword">file</span>.getName();<br>...<br><br></code></pre></td></tr></table></figure><h5 id="那么这个路径到底对不对呢？"><a href="#那么这个路径到底对不对呢？" class="headerlink" title="那么这个路径到底对不对呢？"></a>那么这个路径到底对不对呢？</h5><p>在程序执行过程中，如果路径出现问题，会报错。<br>一般来说面临两个问题：</p><ol><li>路径拼错了</li><li>对应目录不存在</li></ol><p>对于路径拼错这个问题，双十一重新买双手买个脑子能解决。</p><p>对于对应目录不存在这个问题，如果进行后续操作会遇到问题，比如打开一个不存在的文件，这是比较反智的。因此一般会进行如下操作：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(“PATH”);<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">file</span>.exists())&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">file</span>.createNewFile();<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>System.out.<span class="hljs-keyword">println</span>(“<span class="hljs-keyword">File</span> exists!”);<br><span class="hljs-keyword">file</span>.xxxxx();<br>&#125;<br><br><span class="hljs-comment">//同理：上述代码创建文件，我们也可以创建文件夹</span><br><br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">file</span>.exists())&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">file</span>.mkdir();<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>System.out.<span class="hljs-keyword">println</span>(“Directory exists!”);<br><span class="hljs-keyword">file</span>.xxxxx();<br>&#125;<br><span class="hljs-comment">/* 创建文件夹时，注意到有两个方法：</span><br><span class="hljs-comment">* mkdir()</span><br><span class="hljs-comment">* mkdirs()：可以一次性创建多层文件夹</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>File类关注文件本身，可以操作文件的各种属性。但对于文件内部的具体内容，需要引入流的观念。</p><h5 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h5><h6 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h6><p>“流”可以分为输入输出流，类比物理学的“参考系”说明方法而言，如果以Java程序为参考系，Java获取到的数据就是输入流，Java送出的数据就是输出流。</p><h6 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h6><p>字节流：(Byte Stream)针对二进制类型数据<br>字符流：(Char Stream)针对字符类型数据<br>具体使用字节流还是字符流还是要看要操作什么类型的数据。都是统称，下面还包含很多东西。</p><h6 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h6><p>节点流：直接和操作对象接触<br>处理流：处理已经存在的流（包括节点流和处理流）</p><h4 id="字节流：InputStream接口、OutputStream接口"><a href="#字节流：InputStream接口、OutputStream接口" class="headerlink" title="字节流：InputStream接口、OutputStream接口"></a>字节流：InputStream接口、OutputStream接口</h4><h5 id="FileInputStream类、FileOutStream类"><a href="#FileInputStream类、FileOutStream类" class="headerlink" title="FileInputStream类、FileOutStream类"></a>FileInputStream类、FileOutStream类</h5><p>读取文本和写入文本</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">File file = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(PATH)</span>;<br><span class="hljs-comment">// 1. 读取数据</span><br>...<br>FileInputStream FIS = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileInputStream(<span class="hljs-params">file</span>)</span>;<br><span class="hljs-comment">// 逐字节读取文件中的数据</span><br><span class="hljs-built_in">int</span> i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FIS</span>.</span></span>read<span class="hljs-literal">()</span>;<span class="hljs-comment">//转换成ASCII码</span><br><span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>i=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FIS</span>.</span></span>read<span class="hljs-literal">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 按字节数独取文件中的数据</span><br>Byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = <span class="hljs-keyword">new</span> Byte<span class="hljs-literal">[<span class="hljs-number">1024</span>]</span>;<br><span class="hljs-built_in">int</span> i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FIS</span>.</span></span>read(<span class="hljs-built_in">bytes</span>);<span class="hljs-comment">// 每次独取1KB，独取到的内容存放在bytes数据里，返回共读取的字节数</span><br><br><span class="hljs-comment">// 2. 写入数据</span><br>FileOutputStream FOS = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FOS(<span class="hljs-params">file</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FOS</span>.</span></span>write(<span class="hljs-built_in">bytes</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FOS</span>.</span></span>write(<span class="hljs-built_in">bytes</span>,<span class="hljs-literal">true</span>);<span class="hljs-comment">//true代表不覆盖写，而是在后边追加</span><br>...<br></code></pre></td></tr></table></figure><h4 id="字符流：Reader接口、Writer接口"><a href="#字符流：Reader接口、Writer接口" class="headerlink" title="字符流：Reader接口、Writer接口"></a>字符流：Reader接口、Writer接口</h4><h5 id="Reader接口-实现类"><a href="#Reader接口-实现类" class="headerlink" title="Reader接口 实现类"></a>Reader接口 实现类</h5><p><img src="https://i.loli.net/2020/11/12/pzCJ5WHZbwax1Bm.jpg" alt="Alt"></p><blockquote><p>BufferedReader<br>FileReader<br>InputStreamReader<br>…</p></blockquote><h6 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h6><p>InputStreamReader和FileInputStream很像，一个是按字节byte读取，一个是按照字符char读取</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">File file = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(PATH)</span>;<br><br>FileInputStream FIS = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileInputStream(<span class="hljs-params">file</span>)</span>;<br>InputStreamReader ISR = <span class="hljs-keyword">new</span> <span class="hljs-constructor">InputStreamReader(FIS,’<span class="hljs-params">gbk</span>’)</span>;<br><br><span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span><span class="hljs-literal">[<span class="hljs-number">64</span>]</span>;<br><span class="hljs-built_in">int</span> read = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ISR</span>.</span></span>read(c);<br></code></pre></td></tr></table></figure><h6 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h6><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">FileReader FR = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileReader(<span class="hljs-params">file</span>)</span>;<br><br><span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span><span class="hljs-literal">[<span class="hljs-number">64</span>]</span>;<br><br><span class="hljs-built_in">int</span> i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FR</span>.</span></span>read(c);<br><br></code></pre></td></tr></table></figure><h6 id="BufferReader类"><a href="#BufferReader类" class="headerlink" title="BufferReader类"></a>BufferReader类</h6><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs processing">FileInputStream FIS = <span class="hljs-keyword">new</span> FileInputStream(file);<br><br>InputStreamReader ISR = <span class="hljs-keyword">new</span> InputStreamReader(FIS);<br><br><span class="hljs-keyword">BufferedReader</span> BR = <span class="hljs-keyword">new</span> <span class="hljs-keyword">BufferedReader</span>(ISR);<br><br><span class="hljs-keyword">String</span> <span class="hljs-built_in">line</span> = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">//可以一行一行读取，不用破坏文本原来结构</span><br><span class="hljs-keyword">while</span>((<span class="hljs-built_in">line</span> = BR.readLine())!=<span class="hljs-keyword">null</span>)&#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">line</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Writer接口-实现类"><a href="#Writer接口-实现类" class="headerlink" title="Writer接口 实现类"></a>Writer接口 实现类</h5><p>与Reader接口差不多，对应理解即可</p><h4 id="IO流的关闭"><a href="#IO流的关闭" class="headerlink" title="IO流的关闭"></a>IO流的关闭</h4><p>JDK1.6之前需要手动关闭，之后Java可以自动关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">try(&#x2F;&#x2F;放各种需要关闭的可能出现异常的流<br>...<br>FileInputStream FIS &#x3D; new FileInputStream(file);<br>...<br>)<br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>推荐博客：<br>1、juejin.im/post/6844903910348603405<br>2、赵彦军的博客（CSDN）</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>numpy对数据集的基本操作：归一化、最值、均值、读取与保存</title>
    <link href="/2021/01/20/numpy%E5%AF%B9%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%9A%E5%BD%92%E4%B8%80%E5%8C%96%E3%80%81%E6%9C%80%E5%80%BC%E3%80%81%E5%9D%87%E5%80%BC%E3%80%81%E8%AF%BB%E5%8F%96%E4%B8%8E%E4%BF%9D%E5%AD%98/"/>
    <url>/2021/01/20/numpy%E5%AF%B9%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%9A%E5%BD%92%E4%B8%80%E5%8C%96%E3%80%81%E6%9C%80%E5%80%BC%E3%80%81%E5%9D%87%E5%80%BC%E3%80%81%E8%AF%BB%E5%8F%96%E4%B8%8E%E4%BF%9D%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="numpy对数据集的基本操作：归一化、最值、均值、读取与保存"><a href="#numpy对数据集的基本操作：归一化、最值、均值、读取与保存" class="headerlink" title="numpy对数据集的基本操作：归一化、最值、均值、读取与保存"></a>numpy对数据集的基本操作：归一化、最值、均值、读取与保存</h1><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><h2 id="一、-numpy对数据集的存取"><a href="#一、-numpy对数据集的存取" class="headerlink" title="一、 numpy对数据集的存取"></a>一、 numpy对数据集的存取</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta"># 当前工作目录</span><br><span class="hljs-symbol">pwd:</span> ~<br><br><span class="hljs-symbol">origin_dataset:</span> ~/example.csv<br></code></pre></td></tr></table></figure><p>最正宗的展示格式应该是txt，但csv格式文件只不过是用分隔符分开的数据组成的简单文本文件，因此这里用csv也无伤大雅。而且许多数据集也都是csv格式。</p><ol><li><strong>读取</strong>csv到变量：loadtxt()</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">np</span><span class="hljs-selector-class">.loadtxt</span>(<span class="hljs-selector-tag">filepath</span>, <span class="hljs-selector-tag">delimiter</span>, <span class="hljs-selector-tag">usecols</span>, <span class="hljs-selector-tag">unpack</span>, ...)<br></code></pre></td></tr></table></figure><ul><li><strong>filepath</strong>:加载文件路径</li><li><strong>delimiter</strong>:加载文件分隔符</li><li><strong>usecols</strong>:加载数据文件中列索引,<strong>人话</strong>：<em>指定加载数据中的第几列，默认全加载</em></li><li><strong>unpack</strong>:当加载多列数据时是否需要将数据列进行解耦赋值给不同的变量</li></ul><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">data_path = <span class="hljs-string">&quot;~/example.csv&quot;</span></span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">data = np.loadtxt(data_path, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>)</span><br><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">data</span><br>([...]<br>    [...]<br>    ...<br>    [...])<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>保存</strong>变量到文件：savetxt()</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">np</span>.savetxt(fileName, <span class="hljs-class"><span class="hljs-keyword">data</span>, ...)</span><br></code></pre></td></tr></table></figure><ul><li><strong>fileName</strong>:保存文件路径和名称</li><li><strong>data</strong>:需要保存的数据</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">data_path</span> = <span class="hljs-string">&quot;~/example.csv&quot;</span><br><span class="hljs-title">np</span>.savetxt(<span class="hljs-string">&quot;saveddata.csv&quot;</span>, <span class="hljs-class"><span class="hljs-keyword">data</span>)</span><br></code></pre></td></tr></table></figure><h2 id="二、numpy获取最值、均值"><a href="#二、numpy获取最值、均值" class="headerlink" title="二、numpy获取最值、均值"></a>二、numpy获取最值、均值</h2><p>测试数据</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">&gt;&gt;&gt; a=<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[2,5,7]</span>,<span class="hljs-comment">[6,3,6]</span>,<span class="hljs-comment">[7,3,2]</span>]</span><br>&gt;&gt;&gt; x=np.asanyarray(a)<br>&gt;&gt;&gt; x<br>array(<span class="hljs-comment">[<span class="hljs-comment">[1, 2, 3]</span>,</span><br><span class="hljs-comment">       <span class="hljs-comment">[2, 5, 7]</span>,</span><br><span class="hljs-comment">       <span class="hljs-comment">[6, 3, 6]</span>,</span><br><span class="hljs-comment">       <span class="hljs-comment">[7, 3, 2]</span>]</span>)<br></code></pre></td></tr></table></figure><p>numpy集成了获取数据最值、均值甚至更多操作的方法，这一点用起来和matlab很像</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">np.<span class="hljs-keyword">max</span>(<span class="hljs-built_in">data</span>, axis, <span class="hljs-params">...</span>)<br>np.<span class="hljs-keyword">min</span>(<span class="hljs-built_in">data</span>, axis, <span class="hljs-params">...</span>)<br>np.mean(<span class="hljs-built_in">data</span>, axis, <span class="hljs-params">...</span>)<br></code></pre></td></tr></table></figure><p>需要注意的是最常用的<code>axis</code>选项，对于2维数组（矩阵）而言：</p><ul><li><strong>axis = None</strong>: （默认）返回所有数据（行、列）中的最值/均值，返回一个数</li><li><strong>axis = 0</strong>: 返回所有列的最值/均值，相当于返回一个行向量（元素数与<strong>列数</strong>相同的array）</li><li><strong>axis = 1</strong>: 返回所有行的最值/均值，相当于返回一个列向量（元素数与<strong>行数</strong>相同的array）</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">max</span>(x)<br><span class="hljs-number">7</span><br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">max</span>(x,axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">array</span>([<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>])<br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">max</span>(x,axis=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">array</span>([<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>])<br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">min</span>(x)<br><span class="hljs-number">1</span><br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">min</span>(x,axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])<br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">min</span>(x,axis=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>])<br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">mean</span>(x)<br><span class="hljs-number">3.9166666666666665</span><br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">mean</span>(x,axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">array</span>([<span class="hljs-number">4</span>.  , <span class="hljs-number">3.25</span>, <span class="hljs-number">4.5</span> ])<br><br>&gt;&gt;&gt; <span class="hljs-built_in">np</span>.<span class="hljs-built_in">mean</span>(x,axis=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">array</span>([<span class="hljs-number">2</span>.        , <span class="hljs-number">4.66666667</span>, <span class="hljs-number">5</span>.        , <span class="hljs-number">4</span>.        ])<br></code></pre></td></tr></table></figure><h2 id="三、numpy对数据进行归一化"><a href="#三、numpy对数据进行归一化" class="headerlink" title="三、numpy对数据进行归一化"></a>三、numpy对数据进行归一化</h2><p>以下是笔者处理KDD99数据集时归一化的小demo，也是在此途中遇到的上述问题，记录下来，供自己以后参考。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;normlizing...&#x27;</span>)<br>kdd99_numeric = np.loadtxt(numeric_datasets, <span class="hljs-attribute">delimiter</span>=<span class="hljs-string">&#x27;,&#x27;</span>)<br>mean = np.mean(kdd99_numeric, <span class="hljs-attribute">axis</span>=0)<br>max = np.max(kdd99_numeric, <span class="hljs-attribute">axis</span>=0) + 1e-8<br>min = np.min(kdd99_numeric, <span class="hljs-attribute">axis</span>=0)<br>kdd99_numeric_norm = (kdd99_numeric - mean) / (max - min)<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;Done&#x27;</span>)<br><span class="hljs-builtin-name">print</span>(kdd99_numeric_norm)<br><br>np.savetxt(norm_numeric_datasets, kdd99_numeric_norm, <span class="hljs-attribute">delimiter</span>=<span class="hljs-string">&#x27;,&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上述使用的是所谓 <strong>min-max标准化（Min-Max Normalization）（线性函数归一化）</strong> 方法，除此之外，在笔者还了解到还存在 <strong>Z-score标准化方法</strong> ，关于此信息可以查阅参考资料[2]。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]. <a href="https://blog.csdn.net/MESSI_JAMES/article/details/80487389">Numpy读取csv文件</a><br>[2]. <a href="https://blog.csdn.net/program_developer/article/details/78637711">机器学习-数据归一化方法（Normalization Method）</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python日积月累</title>
    <link href="/2021/01/19/Python%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    <url>/2021/01/19/Python%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="python-判断元素是否包含于list"><a href="#python-判断元素是否包含于list" class="headerlink" title="python 判断元素是否包含于list"></a>python 判断元素是否包含于list</h1><p>这里涉及到list的查找方法，参考<a href="https://blog.csdn.net/lachesis999/article/details/53185299">python中list的四种查找方法</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2</span> <span class="hljs-keyword">in</span> a<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">9</span> <span class="hljs-keyword">in</span> a<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> a<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">9</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> a<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="Python-拟合正态分布"><a href="#Python-拟合正态分布" class="headerlink" title="Python 拟合正态分布"></a>Python 拟合正态分布</h1><p><strong>待解决的问题</strong>：对一个一维的数串拟合到正态分布。<br>所谓拟合正态分布，实质上算出均值 $ \mu $ 和方差 $ \sigma^2 $ 即可确定分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>X = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">34</span>,<span class="hljs-number">3</span>,<span class="hljs-number">23</span>,<span class="hljs-number">56</span>,<span class="hljs-number">7</span>,<span class="hljs-number">87</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">34</span>,<span class="hljs-number">5678</span>,<span class="hljs-number">7</span>,<span class="hljs-number">654</span>,<span class="hljs-number">3</span>,<span class="hljs-number">45</span>,<span class="hljs-number">67</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>mu = np.mean(X)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sigma = np.std(X)<br><span class="hljs-meta">&gt;&gt;&gt; </span>mu,sigma**<span class="hljs-number">2</span><br>(<span class="hljs-number">320.3809523809524</span>, <span class="hljs-number">1453914.5215419505</span>)<br></code></pre></td></tr></table></figure><h1 id="Python-中三元表达式的实现"><a href="#Python-中三元表达式的实现" class="headerlink" title="Python 中三元表达式的实现"></a>Python 中三元表达式的实现</h1><p>C语言等其它高级语言中，都有<code>?:</code>这样的三元表达式替换复杂的<code>if else</code>。</p><p>在<code>python</code>中，本身没有三元表达式，但可以利用下面的简单语句实现相似功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python">A <span class="hljs-keyword">if</span> a&gt;b <span class="hljs-keyword">else</span> B<br><span class="hljs-comment"># 等价于</span><br><span class="hljs-keyword">if</span> a&gt;b:<br>    <span class="hljs-keyword">return</span> A<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> B<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python">(B ,A )[a&gt;b] <span class="hljs-comment"># (假则, 真则)[判断]</span><br><span class="hljs-comment"># 等价于</span><br><span class="hljs-keyword">if</span> a&gt;b:<br>    <span class="hljs-keyword">return</span> A<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> B<br></code></pre></td></tr></table></figure><p>但第二种方法比较不受程序员们的待见，实质上是利用了将<code>False</code>等同于<code>0</code>，将<code>True</code>等同于<code>1</code>，然后对前边的<code>tuple</code>进行索引。</p><p><strong>参考</strong><br>[1]. <a href="https://blog.csdn.net/Sinchb/article/details/8081754">python 中 ? : 三元表达式 的实现方式</a><br>[1]. <a href="https://eastlakeside.gitbook.io/interpy-zh/ternary_operators">三元运算符- Python进阶</a><br>[3]. <a href="https://www.cnblogs.com/mywood/p/7416893.html">python中的三元表达式（三目运算符）</a></p><h1 id="进度条工具TQDM"><a href="#进度条工具TQDM" class="headerlink" title="进度条工具TQDM"></a>进度条工具TQDM</h1><p><a href="https://github.com/tqdm/tqdm">GitHub项目地址</a><br><a href="https://tqdm.github.io/">文档地址</a></p><p>看上去很酷炫的进度条工具，可以可视化<strong>time consuming</strong>的程序等待过程。</p><p>使用方法在<code>PySAD</code>的<a href="https://pysad.readthedocs.io/en/latest/examples.html#example-full-usage">Example</a>中有体现。</p><p><img src="https://raw.githubusercontent.com/tqdm/img/master/tqdm.gif" alt="项目仓库中的示例"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>日积月累</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python的符号分隔值格式(xsv)文件读取</title>
    <link href="/2021/01/18/Python%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%88%86%E9%9A%94%E5%80%BC%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <url>/2021/01/18/Python%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%88%86%E9%9A%94%E5%80%BC%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Python的符号分隔值格式-xsv-文件读取"><a href="#Python的符号分隔值格式-xsv-文件读取" class="headerlink" title="Python的符号分隔值格式(xsv)文件读取"></a>Python的符号分隔值格式(xsv)文件读取</h1><h2 id="一、xsv文件介绍"><a href="#一、xsv文件介绍" class="headerlink" title="一、xsv文件介绍"></a>一、xsv文件介绍</h2><p>xsv(x-separated values)x分隔值文件格式，最常见的是</p><blockquote><p>csv(Comma-Separated Values, 逗号分隔值)<br>tsv(Tab-separated values, 制表符分隔值)<br><font size=2, color='gray'> xsv 名称是笔者杜撰，不确定是否真的有这个叫法，也不确定除了上述两种格式是否还有其它格式，即其它分隔方式。这样做的目的是将此类文件统称起来。 </font></p></blockquote><p>一定意义上来说，这类文件格式的区别其实就是分隔符不同，在python中体现为<code>delimiter</code>等参数不同。</p><p>此类文件用简单的<strong>文件编辑器</strong>即可打开，如 <em>Windows系统自带的记事本(nptepad)、关爱孤儿的vim编辑器</em> 以及 <em>VSCode</em> 等。不过一般此类文件用于存储大批量有规则的数据，主要使用<code>code</code>进行批量自动化读取和更多操作。</p><p>以下是来自wikipida的解释：</p><h3 id="1、csv格式"><a href="#1、csv格式" class="headerlink" title="1、csv格式"></a>1、csv格式</h3><p>制表符分隔值 （Tab-separated values，TSV）格式文件是一种用于储存数据的文本格式文件，其数据以表格结构（例如 数据库 或 电子表格 数据）储存。每一行储存一条记录。 每条记录的各个字段间以制表符作为分隔。</p><p>TSV 格式是一种被广泛支持的文件格式，它经常用来在不同的计算机程序之间传递数据，支持格式。 例如，TSV文件可以用来在数据库和电子表格之间传递数据。</p><p>TSV 格式是逗号分隔值（CSV）格式的一种变体，CSV 格式以逗号作为字段间的分隔符号，因为逗号本身是一种很常见的文本数据，因此常常会引起一些问题，而制表符在文本数据中相对少见。在 IANA 标准中，数据字段内禁止使用制表符。</p><h3 id="2、tsv格式"><a href="#2、tsv格式" class="headerlink" title="2、tsv格式"></a>2、tsv格式</h3><p>逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。通常，所有记录都有完全相同的字段序列。</p><p>CSV文件格式的通用标准并不存在，但是在RFC 4180中有基础性的描述。使用的字符编码同样没有被指定，但是7-bit ASCII是最基本的通用编码。</p><ul><li>由于笔者是通过关注到tshark解析pcap文件的代码了解到tsv文件的，因此以下记录了解析得到的tsv文件的文件头部（位于tsv文件的第一行，指示了后序每行数据每列代表的内容）</li></ul><p><img src="https://gitee.com/songz7026/image-pool/raw/master/Python/xsv_tsv_header.jpg" alt="pcap解析得到的tsv文件的文件头"></p><h2 id="二、Python-I-O-简介（文件读取）"><a href="#二、Python-I-O-简介（文件读取）" class="headerlink" title="二、Python I/O 简介（文件读取）"></a>二、Python I/O 简介（文件读取）</h2><p>涉及到对xsv文件的操作，需要了解Python文件读取的主要方法。</p><h3 id="1、open-filename-mode-…"><a href="#1、open-filename-mode-…" class="headerlink" title="1、open(filename, mode, …)"></a>1、open(filename, mode, …)</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">open</span>(filename, <span class="hljs-keyword">mode</span>, ...)<br>(<span class="hljs-symbol">&lt;PATH&gt;</span>, <span class="hljs-string">&quot;rwxts...&quot;</span>, ...)//<span class="hljs-keyword">mode</span>可以参看builtins.<span class="hljs-keyword">py</span>源代码中的注释<br></code></pre></td></tr></table></figure><ul><li><code>return</code>: 方法返回一个<code>file</code>对象，该对象可以进行进一步操作。</li><li><code>filename</code>: 操作的的文件路径</li><li><code>mode</code>: 文件操作模式选项，可以进一步细分为<code>rwx...</code><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">========= ===============================================================<br>Character Meaning 来自builtins.<span class="hljs-keyword">py</span>中<span class="hljs-keyword">open</span>()方法下的注释<br>--------- ---------------------------------------------------------------<br>文件打开模式，特别注意光标的位置（光标向后的位置会被覆盖）<br><span class="hljs-string">&#x27;r&#x27;</span>       <span class="hljs-keyword">open</span> <span class="hljs-keyword">for</span> reading (default) 只读(默认) 光标位于开头<br><span class="hljs-string">&#x27;w&#x27;</span>       <span class="hljs-keyword">open</span> <span class="hljs-keyword">for</span> writing, truncating the <span class="hljs-keyword">file</span> <span class="hljs-keyword">first</span> 只写 光标位于开头 原有内容删除 若文件不存在则新建文件<br><span class="hljs-string">&#x27;x&#x27;</span>       create <span class="hljs-keyword">a</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">file</span> <span class="hljs-built_in">and</span> <span class="hljs-keyword">open</span> it <span class="hljs-keyword">for</span> writing 只写 新建文件 如果该文件已存在则会报错<br><span class="hljs-string">&#x27;a&#x27;</span>       <span class="hljs-keyword">open</span> <span class="hljs-keyword">for</span> writing, appending <span class="hljs-keyword">to</span> the end of the <span class="hljs-keyword">file</span> <span class="hljs-keyword">if</span> it <span class="hljs-built_in">exists</span> 只写（追加<span class="hljs-keyword">append</span>） 光标位于最后 若文件不存在则新建文件<br><br>返回文件的形式<br><span class="hljs-string">&#x27;b&#x27;</span>       binary <span class="hljs-keyword">mode</span> 返回binary文件， 对于<span class="hljs-string">&#x27;byte&#x27;</span>组成的文件<br><span class="hljs-string">&#x27;t&#x27;</span>       text <span class="hljs-keyword">mode</span> (default) 返回文本文件， 对于<span class="hljs-string">&quot;str&quot;</span>组成的文件 <br>覆盖<br><span class="hljs-string">&#x27;+&#x27;</span>       <span class="hljs-keyword">open</span> <span class="hljs-keyword">a</span> disk <span class="hljs-keyword">file</span> <span class="hljs-keyword">for</span> updating (reading <span class="hljs-built_in">and</span> writing) 打开一个文件进行更新(可读可写)<br><br>其它<br><span class="hljs-string">&#x27;U&#x27;</span>       universal newline <span class="hljs-keyword">mode</span> (deprecated) 通用换行模式<br>========= ===============================================================<br></code></pre></td></tr></table></figure>关于open()方法更详细的操作可以参考</li></ul><ol><li>源代码( <em>在编辑器中查找open()的定义位置</em> )中的注释，</li><li><a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files">官方文档</a></li><li><a href="https://www.runoob.com/python/python-func-open.html">菜鸟教程：Python open() 函数</a></li></ol><h4 id="file对象方法"><a href="#file对象方法" class="headerlink" title="file对象方法"></a><code>file</code>对象方法</h4><ul><li><code>file.read([size])</code>：size 未指定则返回整个文件，如果文件大小 &gt;2 倍内存则有问题，f.read()读到文件尾时返回””(空字串)。</li><li><code>file.readline()</code>：返回一行。</li><li><code>file.readlines([size])</code>：返回包含size行的列表, size 未指定则返回全部行。</li><li><code>for line in f: print line</code> ：通过迭代器访问。</li><li><code>f.write(&quot;hello\n&quot;)</code>：如果要写入字符串以外的数据,先将他转换为字符串。</li><li><code>f.tell()</code>：返回一个整数,表示当前文件指针的位置(就是到文件头的字节数)。</li><li><code>f.seek(偏移量,[起始位置])</code>：用来移动文件指针。<br>偏移量: 单位为字节，可正可负<br>起始位置: <strong>0</strong> - 文件头, 默认值; <strong>1</strong> - 当前位置; <strong>2</strong> - 文件尾</li><li><code>f.close()</code>： 关闭文件</li></ul><h3 id="2、with关键字"><a href="#2、with关键字" class="headerlink" title="2、with关键字"></a>2、with关键字</h3><blockquote><p>引子：使用内置open()打开文件之后，要close()以正确关闭以释放资源</p></blockquote><p><code>open()</code>操作常常与<code>with</code>关键字连用，解决引子中麻烦的累赘问题</p><ul><li>对比之后，显而易见</li></ul><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">try</span></span> <span class="hljs-function"><span class="hljs-title">open</span>():</span><br><span class="hljs-function">...</span><br><span class="hljs-function"><span class="hljs-variable"><span class="hljs-keyword">finally</span></span>:</span><br><span class="hljs-function"><span class="hljs-title">close</span>()</span><br></code></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">with</span> <span class="hljs-keyword">open</span>()<br>...<span class="hljs-comment">//更加简洁，自动关闭</span><br></code></pre></td></tr></table></figure><h2 id="三、Python对xsv的支持"><a href="#三、Python对xsv的支持" class="headerlink" title="三、Python对xsv的支持"></a>三、Python对xsv的支持</h2><p>在Python中，有对csv的支持，其它变体（包括tsv）一律视为其中的<code>delimiter</code>等参数不同。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> csv<br></code></pre></td></tr></table></figure><p><a href="https://docs.python.org/3/library/csv.html">Python csv Document</a></p><p><a href="https://docs.python.org/zh-cn/3/library/csv.html">Python csv 官方文档</a></p><h3 id="1、csv文件的读取"><a href="#1、csv文件的读取" class="headerlink" title="1、csv文件的读取"></a>1、csv文件的读取</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">csv.reader(csvfile, <span class="hljs-attribute">dialect</span>=<span class="hljs-string">&#x27;excel&#x27;</span>, *<span class="hljs-number">*f</span>mtparams)<br></code></pre></td></tr></table></figure><ul><li><code>return</code>: <code>reader</code>对象</li><li><code>csvfile</code>: 文件路径</li><li><code>dialect</code>: 指明读取的对象是何种csv文件的变体，如tsv。</li><li><code>**fmtparams</code>：<strong>变种与格式参数</strong> 覆盖当前变种(dialect)的单个格式设置</li></ul><blockquote><p>Python认定csv格式的各种变种都是通过改了一堆参数得到的，（参见python文档），如</p><blockquote><p>dialect.delimiler 用于分隔字段的单字符，默认为逗号”,”<br>dialect.doublequole …<br>dialect.escapechar …<br>..</p></blockquote></blockquote><h3 id="2、iterator迭代器"><a href="#2、iterator迭代器" class="headerlink" title="2、iterator迭代器"></a>2、iterator迭代器</h3><p>引子：csv.reader()使用的对象只需要下列两点，即可顺利打开</p><blockquote><ol><li>满足iterator协议</li><li>并且每次都调用<code>__next__()</code>方法都返回<code>str</code> </li></ol><p>关键字：iterator协议；__next()__</p></blockquote><p><strong>迭代器对象</strong>：表示一串数据的对象，如<code>csv.reader()</code>返回的<code>reader</code>对象。配合使用<code>__next__()</code>方法即可逐行获得字符串。</p><p><img src="https://gitee.com/songz7026/image-pool/raw/master/Python/xsv_iterator.png" alt="iterator对象示意图"></p><ul><li><code>__next__()</code>：返回迭代器对象中的下一项，到达最后一项溢出会引发<code>StopIteration</code>异常</li></ul><h3 id="3、csv-reader-和csv-writerow"><a href="#3、csv-reader-和csv-writerow" class="headerlink" title="3、csv.reader()和csv.writerow()"></a>3、csv.reader()和csv.writerow()</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span> datasets1 = <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-comment"># 设置文件路径</span><br><span class="hljs-meta">&gt;&gt;</span> obj_file1 = open(datasets1) <span class="hljs-comment"># 获得file类型文件obj_file</span><br><span class="hljs-meta">&gt;&gt;</span> obj_reader = csv.reader(obj_file1) <span class="hljs-comment"># 获得reader类型文件；reader(csvfile)接受csvfile类型作为参数，file类型被向下转换到csvfile类型</span><br><br><span class="hljs-meta">&gt;&gt;</span> datasets2 = <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-comment"># 设置文件路径</span><br><span class="hljs-meta">&gt;&gt;</span> obj_file2 = open(datasets2,<span class="hljs-string">&#x27;w&#x27;</span>) <br><span class="hljs-meta">&gt;&gt;</span> obj_file2.writerow([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">33</span>])<br><span class="hljs-meta">&gt;&gt;</span> obj_file2.writerow([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>])<br><span class="hljs-meta">&gt;&gt;</span> obj_file2.writerow([<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>经过测试，发现再writerow()后还插入了一个空行，导致插入多行时会产生大量冗余的空行。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 生成的文件</span><br><span class="hljs-attribute">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">33</span><br><br><span class="hljs-attribute">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">5</span><br><br><span class="hljs-attribute">6</span>，<span class="hljs-number">4</span>，<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>查看文档发现是由于没有在<code>open()</code>阶段设置换行符参数<code>newline</code>，因为不同的系统有不同的换行符，如<code>Windows</code>采用<code>CRLF</code>(回车换行’\r\n’)，<code>Linux</code>采用<code>LF</code>(换行’\n’)。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span> datasets = <span class="hljs-string">&#x27;...&#x27;</span><br><span class="hljs-meta">&gt;&gt;</span> obj_file = open(dataset,<span class="hljs-string">&#x27;w&#x27;</span>,newline=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;</span> obj_file2.writerow([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">33</span>])<br><span class="hljs-meta">&gt;&gt;</span> obj_file2.writerow([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>])<br><span class="hljs-meta">&gt;&gt;</span> obj_file2.writerow([<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 生成的文件</span><br><span class="hljs-attribute">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">33</span><br><span class="hljs-attribute">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">5</span><br><span class="hljs-attribute">6</span>，<span class="hljs-number">4</span>，<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="4、遍历csv"><a href="#4、遍历csv" class="headerlink" title="4、遍历csv"></a>4、遍历csv</h3><p>笔者利用迭代器的<strong>next</strong>()方法在最后一行之后继续调用会产生<code>StopIteration</code>异常这一特性，想出了如下代码以遍历整个csv文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">try</span>:<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>datasets = <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-comment"># 设置文件路径</span><br>obj_file = <span class="hljs-built_in">open</span>(datasets) <span class="hljs-comment"># 获得file类型文件obj_file</span><br>obj_reader = csv.reader(obj_file) <span class="hljs-comment"># 获得reader类型文件；reader(csvfile)接受csvfile类型作为参数，file类型被向下转换到csvfile类型</span><br><br>row = obj_reader.__next__()<br><span class="hljs-keyword">except</span> StopIteration:<br><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h3 id="5、其它"><a href="#5、其它" class="headerlink" title="5、其它"></a>5、其它</h3><p>笔者在测试过程中，发现单纯使用<code>open()</code>得到的<code>file</code>类型也有迭代器方法<code>__next__()</code>，因此将二者做了对比如下。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span> datasets = <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-comment"># 设置文件路径</span><br><span class="hljs-meta">&gt;&gt;</span> obj_file = open(datasets) <span class="hljs-comment"># 获得file类型文件obj_file</span><br><span class="hljs-meta">&gt;&gt;</span> obj_reader = csv.reader(obj_file) <span class="hljs-comment"># 获得reader类型文件；reader(csvfile)接受csvfile类型作为参数，file类型被向下转换到csvfile类型</span><br><br><span class="hljs-meta">&gt;&gt;</span> obj_file.__next__()<br><span class="hljs-string">&#x27;0,tcp,http,SF,181,5450,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,8,8,0.00,0.00,0.00,0.00,1.00,0.00,0.00,9,9,1.00,0.00,0.11,0.00,0.00,0.00,0.00,0.00,normal.\n&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;</span> obj_reader.__next__()<br>[<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;tcp&#x27;</span>, <span class="hljs-string">&#x27;http&#x27;</span>, <span class="hljs-string">&#x27;SF&#x27;</span>, <span class="hljs-string">&#x27;239&#x27;</span>, <span class="hljs-string">&#x27;486&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;1.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;19&#x27;</span>, <span class="hljs-string">&#x27;19&#x27;</span>, <span class="hljs-string">&#x27;1.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.05&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;normal.&#x27;</span>]<br><br><span class="hljs-meta">&gt;&gt;</span> obj_file.__next__()<br><span class="hljs-string">&#x27;0,tcp,http,SF,235,1337,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,8,8,0.00,0.00,0.00,0.00,1.00,0.00,0.00,29,29,1.00,0.00,0.03,0.00,0.00,0.00,0.00,0.00,normal.\n&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;</span> obj_reader.__next__()<br>[<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;tcp&#x27;</span>, <span class="hljs-string">&#x27;http&#x27;</span>, <span class="hljs-string">&#x27;SF&#x27;</span>, <span class="hljs-string">&#x27;219&#x27;</span>, <span class="hljs-string">&#x27;1337&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;1.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;39&#x27;</span>, <span class="hljs-string">&#x27;39&#x27;</span>, <span class="hljs-string">&#x27;1.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.03&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;0.00&#x27;</span>, <span class="hljs-string">&#x27;normal.&#x27;</span>]<br><br><span class="hljs-meta">&gt;&gt;</span> type(obj_file.__next__())<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">str</span>&#x27;&gt;</span><br><br><span class="hljs-meta">&gt;&gt;</span> type(obj_reader.__next__())<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">list</span>&#x27;&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dns"># 实验使用的KDD99_10_percent 最初的几行<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">181,5450,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,8</span>,<span class="hljs-number">8,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,9</span>,<span class="hljs-number">9,1.00,0</span>.<span class="hljs-number">00,0.11,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">239,486,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,8</span>,<span class="hljs-number">8,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,19</span>,<span class="hljs-number">19,1.00,0</span>.<span class="hljs-number">00,0.05,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">235,1337,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,8</span>,<span class="hljs-number">8,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,29</span>,<span class="hljs-number">29,1.00,0</span>.<span class="hljs-number">00,0.03,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">219,1337,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,6</span>,<span class="hljs-number">6,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,39</span>,<span class="hljs-number">39,1.00,0</span>.<span class="hljs-number">00,0.03,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">217,2032,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,6</span>,<span class="hljs-number">6,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,49</span>,<span class="hljs-number">49,1.00,0</span>.<span class="hljs-number">00,0.02,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">217,2032,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,6</span>,<span class="hljs-number">6,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,59</span>,<span class="hljs-number">59,1.00,0</span>.<span class="hljs-number">00,0.02,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">212,1940,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">2,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,1.00,1</span>,<span class="hljs-number">69,1.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">04,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">159,4087,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,5</span>,<span class="hljs-number">5,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,11</span>,<span class="hljs-number">79,1.00,0</span>.<span class="hljs-number">00,0.09,0</span>.<span class="hljs-number">04,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">210,151,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,8,8</span>,<span class="hljs-number">0.00,0.00</span>,<span class="hljs-number">0.00,0.00</span>,<span class="hljs-number">1.00,0.00</span>,<span class="hljs-number">0.00,8,89</span>,<span class="hljs-number">1.00,0.00</span>,<span class="hljs-number">0.12,0.04</span>,<span class="hljs-number">0.00,0.00</span>,<span class="hljs-number">0.00,0.00</span>,normal.<br><span class="hljs-number">0</span>,tcp,http,SF,<span class="hljs-number">212,786,0</span>,<span class="hljs-number">0,0,1,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,8</span>,<span class="hljs-number">8,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00,1.00,0</span>.<span class="hljs-number">00,0.00,8</span>,<span class="hljs-number">99,1.00,0</span>.<span class="hljs-number">00,0.12,0</span>.<span class="hljs-number">05,0.00,0</span>.<span class="hljs-number">00,0.00,0</span>.<span class="hljs-number">00</span>,normal.<br>...<br></code></pre></td></tr></table></figure><p>通过对比可以发现，数据集获得的<code>file</code>对象和<code>reader</code>对象关于迭代方法的异同有</p><ol><li><p>共同点：均可迭代</p></li><li><p>共同点：实验中两个有关联的对象的迭代指针是<strong>共享</strong>的。</p></li><li><p>不同点：返回的类型不同。分别是<code>str</code>和<code>list</code></p></li></ol><p>进一步了解这涉及到了Python中重要的<strong>迭代器</strong>和<strong>生成器</strong>，Python中很多数据类型都可以作为迭代器，关于更详细的迭代器的内容与本文不大，不做赘述。</p><h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><p>[1]. <a href="https://zh.wikipedia.org/wiki/%E5%88%B6%E8%A1%A8%E7%AC%A6%E5%88%86%E9%9A%94%E5%80%BC">wikipida: 制表符分隔值</a><br>[2]. <a href="https://zh.wikipedia.org/wiki/%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94%E5%80%BC">wikipida: 逗号分隔值</a><br>[3]. <a href="https://www.runoob.com/python/python-func-open.html">菜鸟教程：Python open() 函数</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>文件读取(File I/O)</tag>
      
      <tag>迭代器</tag>
      
      <tag>csv文件</tag>
      
      <tag>with()</tag>
      
      <tag>open()</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KDD99数据集的特征(Features)介绍</title>
    <link href="/2021/01/17/KDD99%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%89%B9%E5%BE%81(Features)%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/01/17/KDD99%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%89%B9%E5%BE%81(Features)%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="KDD99数据集的特征-Features-介绍"><a href="#KDD99数据集的特征-Features-介绍" class="headerlink" title="KDD99数据集的特征(Features)介绍"></a>KDD99数据集的特征(Features)介绍</h1><p>KDD99是一个用来从正常连接中监测非正常连接的数据集。产出于1999年Thrid International Knowlegde Discovery and Data Mining Tools Competition，其目的是建立一个稳定的的入侵检测系统。</p><p>KDD99包含了置入攻击的军事网络环境中的记录。攻击可以分类为：</p><ul><li><strong>DoS攻击</strong>：Denial of Service</li><li><strong>R2U</strong>：Remote to User</li><li><strong>U2R</strong>：User to Root</li><li><strong>探针攻击</strong>：Probing</li></ul><p>KDD99数据集是 <em>DARPA数据集</em> 的 <strong>特征提取(Feature Extract)</strong> 版本（ <em>DARPA</em> 是原始数据集）KDD99对每个连接提取了 <strong>41</strong> 个特征，使用<strong>Bro-IDS</strong>工具对数据贴标签。</p><p>其41个特征可以按以下方式分类：</p><ul><li>1-9    TCP连接的基本特征</li><li>10-22    TCP连接的内容特征</li><li>23-31    基于时间的网络流量统计特征，使用2秒的时间窗(Traffic features computed using a two-second time window)</li><li>32-41    基于主机的网络流量统计特征，主机特征(Host features)，用来评估持续时间在两秒钟以上的攻击</li></ul><h2 id="TCP连接的基本特征"><a href="#TCP连接的基本特征" class="headerlink" title="TCP连接的基本特征"></a>TCP连接的基本特征</h2><table><thead><tr><th align="center">feature name</th><th>description</th><th align="center">type</th></tr></thead><tbody><tr><td align="center">duration</td><td>length (number of seconds) of the connection<br>连接的持续时间，以秒(s)为单位<br><strong>[0 ~ 58329]</strong><br>它的定义是从TCP连接以3次握手建立算起，到FIN/ACK连接结束为止的时间；若为UDP协议类型，则将每个UDP数据包作为一条连接。(数据集中出现大量的duration=0 的情况，是因为该条连接的持续时间不足1秒.)</td><td align="center">continuous<br>连续</td></tr><tr><td align="center">protocol_type</td><td>type of the protocol, e.g. tcp, udp, etc.<br>协议类型，此数据集中有三种：<br><strong>TCP, UDP, ICMP</strong></td><td align="center">discrete<br>离散</td></tr><tr><td align="center">service</td><td>network service on the destination, e.g., http, telnet, etc.<br>连接目的端的网络服务。有70+种：<br><strong>aol, auth, bgp, courier, csnet_ns, ctf, daytime, discard, domain, domain_u, echo, eco_i, ecr_i, efs, exec, finger, ftp, ftp_data, gopher, harvest, hostnames, http, http_2784, http_443, http_8001, imap4, IRC, iso_tsap, klogin, kshell, ldap, link, login, mtp, name, netbios_dgm, netbios_ns, netbios_ssn, netstat, nnsp, nntp, ntp_u, other, pm_dump, pop_2, pop_3, printer, private, red_i, remote_job, rje, shell, smtp, sql_net, ssh, sunrpc, supdup, systat, telnet, tftp_u, tim_i, time, urh_i, urp_i, uucp, uucp_path, vmnet, whois, X11, Z39_50</strong></td><td align="center">discrete<br>离散</td></tr><tr><td align="center">src_bytes</td><td>number of data bytes from source to destination<br>从源主机到目的主机数据的字节数<br><strong>[0 ~ 1379963888]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">dst_bytes</td><td>number of data bytes from destination to source<br>从目的主机到源主机数据的字节数<br><strong>[0 ~ 1309937401]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">flag</td><td>normal or error status of the connection<br>连接状态正常或错误的标志，共11中<br><strong>OTH, REJ, RSTO, RSTOS0, RSTR, S0, S1, S2, S3, SF, SH</strong><br>表示该连接是否按照协议要求开始或完成。例如SF表示连接正常建立并终止；S0表示只接到了SYN请求数据包，而没有后面的SYN/ACK。其中SF表示正常，其他10种都是error。<br>11种状态的详细解释，参考文章[4]</td><td align="center">discrete<br>离散</td></tr><tr><td align="center">land</td><td>1 if connection is from/to the same host/port; 0 otherwise<br> <strong>1:</strong> 连接来自/到同一主机/端口<br> <strong>0:</strong> 其它</td><td align="center">discrete<br>离散</td></tr><tr><td align="center">wrong_fragment</td><td>number of ``wrong’’ fragments<br>“错误”片段的数量<br><strong>[0 ~ 3]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">urgent</td><td>number of urgent packets<br>urgent加急包数量<br><strong>[0 ~ 14]</strong></td><td align="center">continuous<br>连续</td></tr></tbody></table><center><p>Table 1: Basic features of individual TCP connections.</p><p>表1：TCP连接的基本特征</p></center><h2 id="TCP连接的内容特征"><a href="#TCP连接的内容特征" class="headerlink" title="TCP连接的内容特征"></a>TCP连接的内容特征</h2><table><thead><tr><th align="center">feature name</th><th>description</th><th align="center">type</th></tr></thead><tbody><tr><td align="center">hot</td><td>number of ``hot’’ indicators<br>访问系统敏感文件和目录的次数<br><strong>[0 ~ 101]</strong><br>例如访问系统目录，建立或执行程序等</td><td align="center">continuous<br>连续</td></tr><tr><td align="center">num_failed_logins</td><td>number of failed login attempts<br>登录尝试失败的次数。<br><strong>[0 ~ 5]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">logged_in</td><td>1 if successfully logged in<br>0 otherwise<br><strong>1</strong>：成功登录<br><strong>0</strong>：其它</td><td align="center">discrete<br>离散</td></tr><tr><td align="center">num_compromised</td><td>number of ``compromised’’ conditions<br>‘compromised’条件出现的次数<br><strong>[0 ~ 7479]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">root_shell</td><td>1 if root shell is obtained; 0 otherwise<br><strong>1</strong>：获得root shell<br><strong>0</strong>：其它</td><td align="center">discrete<br>离散</td></tr><tr><td align="center">su_attempted</td><td>1 if ``su root’’ command attempted; 0 otherwise<br><strong>1</strong>：出现’su root’<br><strong>0</strong>：其它</td><td align="center">discrete<br>离散</td></tr><tr><td align="center">num_root</td><td>number of ``root’’ accesses<br>root用户访问次数<br><strong>[0 ~ 7468]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">num_file_creations</td><td>number of file creation operations<br>文件创建操作的次数<br><strong>[0 ~ 100]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">num_shells</td><td>number of shell prompts<br>使用shell命令的次数<br><strong>[0 ~ 5]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">num_access_files</td><td>number of operations on access control files<br>访问控制文件的次数<br><strong>[0 ~ 9]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">num_outbound_cmds</td><td>number of outbound commands in an ftp session<br>一个FTP会话种出现连接的次数<br><strong>数据集种这一特征出现次数为0</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">is_hot_login</td><td>1 if the login belongs to the ``hot’’ list; 0 otherwise<br><strong>1</strong>：登录属于’hot’列表<br><strong>0</strong>：其它<br>如超级用户或管理员登录</td><td align="center">discrete<br>离散</td></tr><tr><td align="center">is_guest_login</td><td>1 if the login is a ``guest’’login; 0 otherwise<br><strong>1</strong>：guest登录<br><strong>0</strong>：其它</td><td align="center">discrete<br>离散</td></tr></tbody></table><center><p>Table 2: Content features within a connection suggested by domain knowledge.</p><p>表2：TCP连接的内容特征</p></center><h2 id="基于时间的网络流量统计特征"><a href="#基于时间的网络流量统计特征" class="headerlink" title="基于时间的网络流量统计特征"></a>基于时间的网络流量统计特征</h2><table><thead><tr><th align="center">feature name</th><th>description</th><th align="center">type</th></tr></thead><tbody><tr><td align="center">count</td><td>number of connections to the same host as the current connection in the past two seconds<br><strong>Note:</strong> The following  features refer to these same-host connections.<br>过去两秒内，与当前连接具有相同的目标主机的连接数。<br><strong>[0 ~ 511]</strong><br> <strong>注意：</strong> 以下特征连接到相同主机</td><td align="center">continuous<br>连续</td></tr><tr><td align="center">srv_count</td><td>number of connections to the same service as the current connection in the past two seconds<br><strong>Note:</strong> The following features refer to these same-service connections.<br>过去两秒内，与当前连接具有相同服务的连接数<br><strong>[0 ~ 511]</strong><br> <strong>注意：</strong> 以下特征连接到相同服务</td><td align="center">continuous<br>连续</td></tr><tr><td align="center">serror_rate</td><td>% of connections that have ``SYN’’ errors<br>过去两秒内，在与当前连接具有相同目标主机的连接中，出现“SYN” 错误的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">rerror_rate</td><td>% of connections that have ``REJ’’ errors<br>过去两秒内，在与当前连接具有相同目标主机的连接中，出现“REJ” 错误的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">same_srv_rate</td><td>% of connections to the same service<br>过去两秒内，在与当前连接具有相同目标主机的连接中，与当前连接具有相同服务的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">diff_srv_rate</td><td>% of connections to different services<br>过去两秒内，在与当前连接具有相同目标主机的连接中，与当前连接具有不同服务的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">srv_serror_rate</td><td>% of connections that have ``SYN’’ errors<br>过去两秒内，在与当前连接具有相同服务的连接中，出现“SYN” 错误的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">srv_rerror_rate</td><td>% of connections that have ``REJ’’ errors<br>过去两秒内，在与当前连接具有相同服务的连接中，出现“REJ” 错误的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center">srv_diff_host_rate</td><td>% of connections to different hosts<br>过去两秒内，在与当前连接具有相同服务的连接中，与当前连接具有不同目标主机的连接的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">continuous<br>连续</td></tr><tr><td align="center"><font size=2></td><td></td><td align="center"></td></tr></tbody></table><ul><li><p>count、serror_rate、rerror_rate、same_srv_rate、diff_srv_rate这5个特征是 same host特征，前提都是与当前连接具有相同目标主机的连接；</p></li><li><p>srv_count、srv_serror_rate、srv_rerror_rate、srv_diff_host_rate这4个特征是same service特征，前提都是与当前连接具有相同服务的连接。</p></li></ul></font><center>Table 3: Traffic features computed using a two-second time window.<p>表 3：基于时间的网络流量统计特征</p></center><h2 id="基于主机的网络流量统计特征"><a href="#基于主机的网络流量统计特征" class="headerlink" title="基于主机的网络流量统计特征"></a>基于主机的网络流量统计特征</h2><table><thead><tr><th align="center">feature name</th><th>description</th><th align="center">type</th></tr></thead><tbody><tr><td align="center">dst_host_count</td><td>前100个连接中，与当前连接具有相同目标主机的连接数<br><strong>[0 ~ 255]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_srv_count</td><td>前100个连接中，与当前连接具有相同目标主机相同服务的连接数<br><strong>[0 ~ 255]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_same_srv_rate</td><td>前100个连接中，与当前连接具有相同目标主机相同服务的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_diff_srv_rate</td><td>前100个连接中，与当前连接具有相同目标主机不同服务的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_same_src_port_rate</td><td>前100个连接中，与当前连接具有相同目标主机相同源端口的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_srv_diff_host_rate</td><td>前100个连接中，与当前连接具有相同目标主机相同服务的连接中，与当前连接具有不同源主机的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_serror_rate</td><td>前100个连接中，与当前连接具有相同目标主机的连接中，出现SYN错误的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_srv_serror_rate</td><td>前100个连接中，与当前连接具有相同目标主机相同服务的连接中，出现SYN错误的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_rerror_rate</td><td>前100个连接中，与当前连接具有相同目标主机的连接中，出现REJ错误的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr><tr><td align="center">dst_host_srv_rerror_rate</td><td>前100个连接中，与当前连接具有相同目标主机相同服务的连接中，出现REJ错误的连接所占的百分比<br><strong>[0.00 ~ 1.00]</strong></td><td align="center">连续</td></tr></tbody></table><center><p>表 4:基于主机的网络流量统计特征（<a href="http://kdd.ics.uci.edu/databases/kddcup99/task.html">KDD99官网的task部分</a>没找到对应表格）</p></center><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>KDD99在研究者当中十分流行，研究者也对其本身做了很多工作：</p><ul><li>[*]减少特征数量，从最初的41个特征中选择最有用的特征</li><li>[*]指出了KDD99的不足之处<blockquote><ol><li>KDD99面临不平衡的分类方法问题。测试集和训练集的概率分布是不同的，由于在训练集中加入新的攻击，攻击和正常流量的类别的平衡会被打破。[?]</li><li>数据集太老了，可能存在过时的问题</li><li>有研究表明，该数据集存在导致对异常检测性能的过高估计的可能性</li></ol></blockquote></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]. CHAABOUNI N, MOSBAH M, ZEMMARI A, et al. Network Intrusion Detection for IoT Security Based on Learning Techniques [J]. Ieee Communications Surveys and Tutorials, 2019, 21(3): 2671-701.<br>[2]. <a href="http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html">KDD Cup 1999 Data</a><br>[3]. <a href="https://mathpretty.com/10244.html">KDD99数据集与NSL-KDD数据集介绍</a> <em>BTW： 这篇博客对 KDD99 和 NSL-KDD 写的很详细</em><br>[4]. Song J, Takakura H, Okabe Y. Description of kyoto university benchmark data[J]. Available at link: <a href="http://www.takakura.com/Kyoto_data/BenchmarkData-Description-v5.pdf">http://www.takakura.com/Kyoto_data/BenchmarkData-Description-v5.pdf</a> [Accessed on 15 March 2016], 2006.<br>[5]. Özgür A, Erdem H. A review of KDD99 dataset usage in intrusion detection and machine learning between 2010 and 2015[J]. PeerJ Preprints, 2016, 4: e1954v1.</p>]]></content>
    
    
    <categories>
      
      <category>机器学习应用于信息安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KDD99</tag>
      
      <tag>信息安全</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的安装与配置</title>
    <link href="/2021/01/17/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/01/17/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo的安装与初始配置"><a href="#Hexo的安装与初始配置" class="headerlink" title="Hexo的安装与初始配置"></a>Hexo的安装与初始配置</h1><h2 id="一、Hexo安装准备"><a href="#一、Hexo安装准备" class="headerlink" title="一、Hexo安装准备"></a>一、Hexo安装准备</h2><p>安装Hexo的前置需求有：</p><ul><li><strong>Node.js</strong>：主要是使用其中的npm包管理工具（<a href="https://hexo.io/zh-cn/docs/">Hexo官网</a>建议使用Node.js 12.0版本，最低Node.js 10.13） </li><li><strong>Git</strong>：版本控制工具，主要用于博客的版本控制、远端存储和同步</li></ul><h2 id="二、安装Hexo"><a href="#二、安装Hexo" class="headerlink" title="二、安装Hexo"></a>二、安装Hexo</h2><p>安装好上述软件需求后，在shell终端输入以下指令，即可完成安装Hexo。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>安装过程中可能遇到的问题：</p><ol><li>安装过程缓慢或卡在某个过程中不动弹。可以考虑修改npm的默认下载源，如<strong>淘宝镜像源</strong>。</li><li>Windows可以在<strong>Git Bash</strong>中进行类似Linux中的指令。</li></ol><p>安装好hexo之后，如此使用：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ npx hexo &lt;<span class="hljs-keyword">command</span>&gt;<br></code></pre></td></tr></table></figure><p>为了方便起见，我们更倾向于直接使用hexo指令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># hexo <span class="hljs-meta-string">&lt;command&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>方法一：可以考虑将hexo加入PATH</li><li>方法二：设置alias hexo=’npx hexo’</li><li>方法三：(Windows系统)，使用<strong>git bash</strong>貌似可以不用设置环境PATH。但是存在一个小问题，直接运行<strong>git bash</strong>无法正确运行hexo指令，但从文件夹窗口中使用右键菜单<strong>在此处打开git bash</strong>可以直接使用<code>hexo &lt;command&gt;</code></li><li>方法三小问题的原因：<code>hexo &lt;command&gt;</code>需要在blog根目录下执行，因此其它路径会报错。</li></ul><h2 id="三、初始配置"><a href="#三、初始配置" class="headerlink" title="三、初始配置"></a>三、初始配置</h2><p>自此开始，默认使用简化的形式</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ hero &lt;<span class="hljs-keyword">command</span>&gt;<br></code></pre></td></tr></table></figure><p>安装好Hexo之后，要初始化一个工作目录，类似于git中的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>执行指令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;directory&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;directory&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><p>逐条解析：</p><ol><li><code>hexo init &lt;directory&gt;</code>：格式化指定路径为hexo工作目录。</li></ol><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ ll &lt;directory&gt;<br>total 116<br>-rw-r--r--<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span>   <span class="hljs-number"> 0 </span>  _config.landscape.yml<br>-rw-r--r--<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span><span class="hljs-number"> 2545 </span>  _config.yml<br>drwxr-xr-x<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span>   <span class="hljs-number"> 0 </span>  node_modules/<br>-rw-r--r--<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span> <span class="hljs-number"> 641 </span>  package.json<br>-rw-r--r--<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span>57736   package-lock.json<br>drwxr-xr-x<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span>   <span class="hljs-number"> 0 </span>  scaffolds/<br>drwxr-xr-x<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span>   <span class="hljs-number"> 0 </span>  source/<br>drwxr-xr-x<span class="hljs-number"> 1 </span><span class="hljs-number"> 197609 </span>   <span class="hljs-number"> 0 </span>  themes/<br></code></pre></td></tr></table></figure><ol start="2"><li><code>cd &lt;directory&gt;</code>：切换到工作目录</li><li><code>npm install</code>：使用<code>npm</code>根据<code>&lt;directory&gt;</code>中的配置文件下载相关的依赖文件。</li></ol><h2 id="四、个性化设置"><a href="#四、个性化设置" class="headerlink" title="四、个性化设置"></a>四、个性化设置</h2><p>关于hexo博客的个性化设置，离不开<code>&lt;hexo&gt;/_config.yml</code></p><h3 id="1、设置博客标题、基本信息等"><a href="#1、设置博客标题、基本信息等" class="headerlink" title="1、设置博客标题、基本信息等"></a>1、设置博客标题、基本信息等</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">$ vim _config.yml<br>...<br><span class="hljs-comment"># Site</span><br><span class="hljs-section">title: 设置博客标题</span><br><span class="hljs-section">subtitle: &#x27;&#x27;</span><br><span class="hljs-section">description: &#x27;&#x27;</span><br><span class="hljs-section">keywords:</span><br><span class="hljs-section">author: 作者姓名</span><br><span class="hljs-section">language: 语言，中文设置为zh即可</span><br><span class="hljs-section">timezone: 国内一般使用Asia/Shanghai即可</span><br>...<br></code></pre></td></tr></table></figure><p>此处抛砖引玉，更多相关设置使用时实时查阅即可</p><h3 id="2、设置博客主题-theme"><a href="#2、设置博客主题-theme" class="headerlink" title="2、设置博客主题(theme)"></a>2、设置博客主题(theme)</h3><p><a href="https://hexo.io/zh-cn/">Hexo官网</a>共享了很多主题。</p><p><img src="https://gitee.com/songz7026/image-pool/raw/master/note_hexo/hexo_theme.png" alt="Hexo官网主题"></p><p>任选一款进入，即可找到作者的github主页连接，在其中寻找hexo的主题仓库即可，一般在readme中都会详细介绍主题的安装方法。不过一般来说都是一样的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> &lt;directory&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> &lt;github_theme仓库的连接&gt;</span><br></code></pre></td></tr></table></figure><p>在此之后修改<code>_config.yml</code>中的<code>theme</code>即可</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"># Extensions<br>## Plugins: https:<span class="hljs-comment">//hexo.io/plugins/</span><br>## Themes: https:<span class="hljs-comment">//hexo.io/themes/</span><br>theme: 这里这里这里 theme名称填上去就可以了<br></code></pre></td></tr></table></figure><p>个别theme会有自己的安装方法，按照readme详细做就可以了。</p><h2 id="五、查看博客"><a href="#五、查看博客" class="headerlink" title="五、查看博客"></a>五、查看博客</h2><p>在shell中键入以下指令即可开启本地服务，从本地浏览器输入对应连接(下文对应链接为localhost:4000)即可查看</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ hexo <span class="hljs-keyword">server</span><br><span class="hljs-keyword">INFO</span>  Validating config<br><span class="hljs-keyword">INFO</span>  <span class="hljs-keyword">Start</span> processing<br><span class="hljs-keyword">INFO</span>  Hexo <span class="hljs-keyword">is</span> running at http://localhost:<span class="hljs-number">4000</span> . Press Ctrl+C <span class="hljs-keyword">to</span> stop.<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/songz7026/image-pool/raw/master/note_hexo/hexo_init_blog.png" alt="初始状态博客首页"></p><p>使用<code>-o</code>选项可以自动使用系统默认浏览器打开</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span> -o<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
