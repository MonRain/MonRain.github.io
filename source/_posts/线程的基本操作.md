---
title: 线程的基本操作
categories: Java高并发
tags:
  - 高并发
  - Java
  - Thread对象
date: 2021-04-22 14:28:12
---


# 线程的基本操作

## 线程的创建

### 基本的创建线程操作

在Java中，线程操作被包装成了`Thread`类，因此使用

```
Thread myThread = new Thread();
```

即可创建一个线程。

在此线程一般使用`myThread.start()`方法来启动，表现为新的线程执行一次内置的`run()`方法。但默认状态下，`run()`方法并不执行任何操作，是一个空方法。

对于一个自定义线程来说，可以继承`Thread`类之后重写`run()`方法。

```
public class MyThread extends Thread{
	@Override
	public void run(){
		System.out.println("This is a new tread!");
	}
}
```

### 多继承问题

Java并不支持多继承，这导致我们新建自定义线程之后无法集成其它类。`Runnable`接口解决了这个问题。

```
public class MyThread extends OtherClass implements Runnable{
	@Override
	public void run(){
		System.out.println("This thread is got by implementing the Runnable interface!");
	}
}

public MainClass{
	public static void main(String[] args){
		Thread myThread = new Thread(new MyThread())
	}
}
```
在此之中，我们向`Thread`的构造函数中传递了一个继承`Runnable`接口的类。

实际上，`Thread`本身就是基于一个空的`Runnable`新建的，我们只不过是替换了它而已：

## 线程之间的简单交互

基本的线程间交互可以解释为：

> 子线程.join(): 主线程阻塞，等待子线程完成
> 线程.sleep(n): 当前线程等待n时间，让出CPU给其它线程，需要抓取中断异常。（当前线程绝对需要等待）
> 线程.yeild(): 当前线程让出CPU，与同优先级的其他线程一起竞争。（当前线程有竞争机会）
> 线程协作：O.wait()和O.notify()通过传递Object实现线程协作，如生产者消费者模式
